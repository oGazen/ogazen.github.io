<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/68213482?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="##### 法线外扩/视口夹角

<details>
    <summary>Outline3DOutExternal</summary>

```hlsl
Shader 'URP/Outline3DOutExternal'
{
    Properties
    {
        _MainTex ('Texture', 2D) = 'white' {}
        _OutlineColor ('Color',Color) = (1,1,1,1)
        _OutlineWidth ('Outline Width',Range(0,0.1)) = 0.1
        _OutlinePowerIn ('Outline PowerIn',Range(0.01,10)) = 1
    }
    SubShader
    {
  


        Pass
        {
            Name 'Outline3D_Inside'
  
            Tags
            {
                'RenderType'='Opaque'
                'Queue'='Transparent'
                'RenderPipeline'='UniversalPipeline'
                'LightMode'='UniversalForward'
            }
            LOD 100
            Blend SrcAlpha OneMinusSrcAlpha

            HLSLPROGRAM
  
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            #pragma vertex vert;
            #pragma fragment frag;
  
            TEXTURE2D_X(_MainTex);
            SAMPLER(sampler_linear_clamp_MainTex);

            CBUFFER_START(UnityPerMaterial)
                half4 _OutlineColor;
                half _OutlinePowerIn;
            CBUFFER_END
  
            struct Varyings
            {
                half4 position : SV_POSITION;
                half2 uv : TEXCOORD0;
                half3 normal_world : TEXCOORD1;
                half3 position_world : TEXCOORD2;
            };


            Varyings vert(half2 uv : TEXCOORD0,half4 position : POSITION,half4 normal : NORMAL)
            {
                Varyings OUT;
                OUT.position_world = mul(GetObjectToWorldMatrix(),position);
                OUT.normal_world = TransformObjectToWorldNormal(normal);
                OUT.position = TransformObjectToHClip(position);
                OUT.uv = uv;
                return OUT;
            }


            half4 frag(Varyings IN) : SV_Target
            {
                half3 direction_view = normalize(GetCameraPositionWS() - (IN.position_world));
                half v = dot(direction_view,IN.normal_world);
                v = 1 - saturate(v);
                v = pow(v,_OutlinePowerIn);
  
                half4 col = SAMPLE_TEXTURE2D_X(_MainTex,sampler_linear_clamp_MainTex,IN.uv);
                return lerp(col,_OutlineColor,v);
            }
  
            ENDHLSL
        }
  

        Pass
        {
            Name 'Outline3D_Swell'
  
            Tags
            {
                'RenderType'='Opaque'
                'Queue'='Transparent'
                'RenderPipeline'='UniversalPipeline'
                'LightMode'='SRPDefaultUnlit'
            }
            LOD 100
            Blend SrcAlpha OneMinusSrcAlpha
            Cull Front

            HLSLPROGRAM
  
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            #pragma vertex vert;
            #pragma fragment frag;


            TEXTURE2D_X(_MainTex);
            SAMPLER(sampler_linear_clamp_MainTex);

            CBUFFER_START(UnityPerMaterial)
                half4 _OutlineColor;
                half _OutlineWidth;
            CBUFFER_END
  
            struct Varyings
            {
                half4 position : SV_POSITION;
                half2 uv : TEXCOORD0;
            };


            Varyings vert(half2 uv : TEXCOORD0,half4 position : POSITION,half4 normal : NORMAL)
            {
                Varyings OUT;
                position.xyz += normal * _OutlineWidth;
                OUT.position = TransformObjectToHClip(position);
                OUT.uv = uv;
                return OUT;
            }


            half4 frag(Varyings IN) : SV_Target
            {
                return _OutlineColor;
            }
  
            ENDHLSL
        }
    }

    Fallback 'Hidden/Universal Render Pipeline/FallbackError'
}
```

</details>

##### UI描边(配合C#)

<details>
	<summary>OutlineUI</summary>

```hlsl
Shader 'URP/OutlineUI'
{
    Properties
    {
        [PerRendererData]_MainTex ('Main Texture', 2D) = 'white' { }
        [HideInInspector]_Color ('Tint', Color) = (1, 1, 1, 1)

        [HideInInspector]_StencilComp ('Stencil Comparison', Float) = 8
        [HideInInspector]_Stencil ('Stencil ID', Float) = 0
        [HideInInspector]_StencilOp ('Stencil Operation', Float) = 0
        [HideInInspector]_StencilWriteMask ('Stencil Write Mask', Float) = 255
        [HideInInspector]_StencilReadMask ('Stencil Read Mask', Float) = 255

        [HideInInspector]_ColorMask ('Color Mask', Float) = 15

        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip ('Use Alpha Clip', Float) = 0
        _AlphaClipThreshold ('Alpha Clip Threshold',Range(0,1)) = 0.001
        // 注意：Softness属性这里定义只是为了Material Inspector显示，
        // 实际值将由RectMask2D组件通过MaterialPropertyBlock动态覆盖
        _Softness('Softness', Vector) = (0, 0, 0, 0)
    }

    SubShader
    {
        Tags
        {
            'Queue' = 'Transparent'
            'IgnoreProjector' = 'True'
            'RenderType' = 'Transparent'
            'PreviewType' = 'Plane'
            'CanUseSpriteAtlas' = 'True'
            'RenderPipeline' = 'UniversalPipeline'
        }
  

        Pass
        {
            Name 'UIOutlineEx'
  
            Stencil
            {
                Ref [_Stencil]
                Comp [_StencilComp]
                Pass [_StencilOp]
                ReadMask [_StencilReadMask]
                WriteMask [_StencilWriteMask]
            }
  
            Cull Off
            Lighting Off
            ZWrite Off
            ZTest [unity_GUIZTestMode]
            Blend SrcAlpha OneMinusSrcAlpha
            ColorMask [_ColorMask]

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag


            #pragma multi_compile_local _ UNITY_UI_CLIP_RECT
            #pragma multi_compile_local _ UNITY_UI_ALPHACLIP
  
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            half4 _ClipRect;


            CBUFFER_START(UnityPerMaterial)
            half4 _Color;
            float4 _MainTex_TexelSize;
            half4 _Softness;
            half _AlphaClipThreshold;
            CBUFFER_END

            half4 _TextureSampleAdd;

            struct appdata
            {
                float4 vertex : POSITION;
                float4 texcoord : TEXCOORD0;
                float4 uv1 : TEXCOORD1;
                float4 uv2 : TEXCOORD2;
                half4 color : COLOR;
            };


            struct v2f
            {
                float4 vertex : SV_POSITION;
                float4 texcoord : TEXCOORD0;
                float4 uv1 : TEXCOORD1;
                float4 uv2 : TEXCOORD2;
                half4 color : COLOR;

                half4 objPosition : TEXCOORD3;
            };

            v2f vert(appdata IN)
            {
                v2f o;
  
                o.vertex = TransformObjectToHClip(IN.vertex.xyz);
                o.texcoord = IN.texcoord;
                o.color = IN.color * _Color;
                o.uv1 = IN.uv1;
                o.uv2 = IN.uv2;

                o.objPosition = IN.vertex;
                return o;
            }

            half IsInRect(float2 pPos, float2 pClipRectMin, float2 pClipRectMax)
            {
                pPos = step(pClipRectMin, pPos) * step(pPos, pClipRectMax);
                return pPos.x * pPos.y;
            }

            half SampleAlpha(int pIndex, v2f IN)
            {
                const half sinArray[12] =
                {
                    0, 0.5, 0.866, 1, 0.866, 0.5, 0, -0.5, -0.866, -1, -0.866, -0.5
                };
                const half cosArray[12] =
                {
                    1, 0.866, 0.5, 0, -0.5, -0.866, -1, -0.866, -0.5, 0, 0.5, 0.866
                };
                float2 pos = IN.texcoord.xy + _MainTex_TexelSize.xy * float2(cosArray[pIndex], sinArray[pIndex]) * IN.texcoord.z;
                half pos_uv_col_a = (SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, pos) + _TextureSampleAdd).w;
                return IsInRect(pos, IN.uv1.xy, IN.uv1.zw) * pos_uv_col_a * IN.uv2.w;
            }
  
            half4 frag(v2f IN) : SV_Target
            {
                half4 color = (SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.texcoord.xy) + _TextureSampleAdd) * IN.color;

  
                if (all(IN.texcoord.z))
                {
                    half sign_a = IsInRect(IN.texcoord.xy, IN.uv1.xy, IN.uv1.zw);
                    color.a *= sign_a;
                    half4 val = half4(IN.uv2.rgb, 0);

                    val.w += SampleAlpha(0, IN);
                    val.w += SampleAlpha(1, IN);
                    val.w += SampleAlpha(2, IN);
                    val.w += SampleAlpha(3, IN);
                    val.w += SampleAlpha(4, IN);
                    val.w += SampleAlpha(5, IN);
                    val.w += SampleAlpha(6, IN);
                    val.w += SampleAlpha(7, IN);
                    val.w += SampleAlpha(8, IN);
                    val.w += SampleAlpha(9, IN);
                    val.w += SampleAlpha(10, IN);
                    val.w += SampleAlpha(11, IN);
                    val.w = saturate(val.w);

                    val.w *= IN.texcoord.w;
                    color = lerp(val, color, color.a) * val.w + color * (1 - val.w);
                }


               // 2. --- 核心：应用自定义的RectMask2D裁剪（带软边缘）---
                #if UNITY_UI_CLIP_RECT
                // 2.1 计算片元到裁剪矩形四条边的距离
                half2 minDist = (IN.objPosition.xy - _ClipRect.xy);
                half2 maxDist = (_ClipRect.zw - IN.objPosition.xy);
                half2 edgeDistance = min(minDist, maxDist); // 对于矩形内的点，这个值是正的

                // 2.2 计算软边缘因子
                // saturate(x / softness) ：
                // - 当 x > softness：结果 >= 1，完全保留
                // - 当 0 < x < softness：结果在 0 到 1 之间，平滑过渡
                // - 当 x < 0：结果为 0，完全裁剪
                // 使用max(softness, 0.001)避免除以零
                half2 softnessFactor = saturate(edgeDistance / max(_Softness.xy, 0.001));

                // 2.3 综合两个方向的因子（取最小值，这样任何一个方向出界都会导致裁剪）
                half finalAlphaFactor = softnessFactor.x * softnessFactor.y;

                // 2.4 将裁剪因子应用到最终颜色的Alpha通道
                color.a *= finalAlphaFactor;
                #endif

  
                #if UNITY_UI_ALPHACLIP
                    clip(color.a - _AlphaClipThreshold);
                #endif


                return color;
            }

  
            ENDHLSL
        }
    }
}
```

</details>

<details>
	<summary>UIOutlineEx</summary>

```cs
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

/// <summary>
/// UGUI描边
/// </summary>
public class UIOutlineEx : BaseMeshEffect
{
    private static List<UIVertex> m_VetexList = new List<UIVertex>();

    // 公开变量
    public Color OutlineColor = Color.black;
    [Range(0.01f, 6)] public float OutlineWidth = 1;
    [SerializeField] private Material m_outlineMaterial;
    [SerializeField] private bool m_DrawOutline;

    // 私有变量
    private float m_uivertex_alpha_max = 0;
    private CanvasGroup[] m_canvasGroups;
    private float m_canvasGroups_alphamul = 1;


    public void SetDrawOutline(bool draw)
    {
        m_DrawOutline = draw;
    }
  
  
  
    protected override void Awake()
    {
        base.Awake();

        if (base.graphic)
        {
            if (base.graphic.canvas)
            {
                var v1 = base.graphic.canvas.additionalShaderChannels;
                var v2 = AdditionalCanvasShaderChannels.TexCoord1;
                if ((v1 & v2) != v2)
                {
                    base.graphic.canvas.additionalShaderChannels |= v2;
                }
                v2 = AdditionalCanvasShaderChannels.TexCoord2;
                if ((v1 & v2) != v2)
                {
                    base.graphic.canvas.additionalShaderChannels |= v2;
                }
            }
            this._Refresh();
        }
    }

    protected override void OnDestroy()
    {
        base.graphic.material = null;
    }


    protected override void OnEnable()
    {
        base.graphic.material = m_outlineMaterial;
        this._Refresh();
    }

    protected override void OnDisable()
    {
        base.graphic.material = null;
        this._Refresh();
    }

    protected override void Start()
    {
        base.graphic.material = m_outlineMaterial;
    }


    protected override void OnCanvasGroupChanged()
    {
        base.OnCanvasGroupChanged();
        if (m_canvasGroups == null) m_canvasGroups = GetComponentsInParent<CanvasGroup>();

        m_canvasGroups_alphamul = 1;
        for (int i = 0; i < m_canvasGroups.Length; i++)
        {
            m_canvasGroups_alphamul *= m_canvasGroups[i].alpha;
        }
        this._Refresh();
    }
  

    private void _Refresh()
    {
        base.graphic.SetVerticesDirty();
    }


    public override void ModifyMesh(VertexHelper vh)
    {
        if(!m_DrawOutline) return;
  
        vh.GetUIVertexStream(m_VetexList);

        m_uivertex_alpha_max = 0;
        for (int i = 0; i < m_VetexList.Count; i++)
        {
            var v = m_VetexList[i];
            if (v.color.a / 255f > m_uivertex_alpha_max) m_uivertex_alpha_max = v.color.a / 255f;
        }
        m_uivertex_alpha_max *= m_canvasGroups_alphamul;

        this._ProcessVertices();

        vh.Clear();
        vh.AddUIVertexTriangleStream(m_VetexList);
    }


    private void _ProcessVertices()
    {
        for (int i = 0, count = m_VetexList.Count - 3; i <= count; i += 3)
        {
            var v1 = m_VetexList[i];
            var v2 = m_VetexList[i + 1];
            var v3 = m_VetexList[i + 2];
  
  
  
            // 计算原顶点坐标中心点
            //
            var minX = _Min(v1.position.x, v2.position.x, v3.position.x);
            var minY = _Min(v1.position.y, v2.position.y, v3.position.y);
            var maxX = _Max(v1.position.x, v2.position.x, v3.position.x);
            var maxY = _Max(v1.position.y, v2.position.y, v3.position.y);
            var posCenter = new Vector2(minX + maxX, minY + maxY) * 0.5f;
  
  
  
            // 计算原始顶点坐标和UV的方向
            //
            Vector2 triX, triY, uvX, uvY;
            Vector2 pos1 = v1.position;
            Vector2 pos2 = v2.position;
            Vector2 pos3 = v3.position;
            if (Mathf.Abs(Vector2.Dot((pos2 - pos1).normalized, Vector2.right))
                > Mathf.Abs(Vector2.Dot((pos3 - pos2).normalized, Vector2.right)))
            {
                triX = pos2 - pos1;
                triY = pos3 - pos2;
                uvX = v2.uv0 - v1.uv0;
                uvY = v3.uv0 - v2.uv0;
            }
            else
            {
                triX = pos3 - pos2;
                triY = pos2 - pos1;
                uvX = v3.uv0 - v2.uv0;
                uvY = v2.uv0 - v1.uv0;
            }
  
  
  
            // 计算原始UV框
            var uvMin = _Min(v1.uv0, v2.uv0, v3.uv0);
            var uvMax = _Max(v1.uv0, v2.uv0, v3.uv0);

            // 为每个顶点设置新的Position和UV，并传入原始UV框
            v1 = _SetNewPosAndUV(v1, this.OutlineWidth, posCenter, triX, triY, uvX, uvY, uvMin, uvMax);
            v2 = _SetNewPosAndUV(v2, this.OutlineWidth, posCenter, triX, triY, uvX, uvY, uvMin, uvMax);
            v3 = _SetNewPosAndUV(v3, this.OutlineWidth, posCenter, triX, triY, uvX, uvY, uvMin, uvMax);


            // 应用设置后的UIVertex
            //
            m_VetexList[i] = v1;
            m_VetexList[i + 1] = v2;
            m_VetexList[i + 2] = v3;
        }
    }


    private UIVertex _SetNewPosAndUV(
        UIVertex pVertex, float pOutLineWidth,
        Vector2 pPosCenter,
        Vector2 pTriangleX, Vector2 pTriangleY,
        Vector2 pUVX, Vector2 pUVY,
        Vector2 pUVOriginMin, Vector2 pUVOriginMax)
    {
        // Position
        var pos = pVertex.position;
        var posXOffset = pos.x > pPosCenter.x ? pOutLineWidth : -pOutLineWidth;
        var posYOffset = pos.y > pPosCenter.y ? pOutLineWidth : -pOutLineWidth;
        pos.x += posXOffset;
        pos.y += posYOffset;
        pVertex.position = pos;
  
        // UV
        var uv = (Vector2)pVertex.uv0;
        var uv_additional_x = pUVX / pTriangleX.magnitude * posXOffset * (Vector2.Dot(pTriangleX, Vector2.right) > 0 ? 1 : -1);
        var uv_additional_y = pUVY / pTriangleY.magnitude * posYOffset * (Vector2.Dot(pTriangleY, Vector2.up) > 0 ? 1 : -1);
        uv += uv_additional_x;
        uv += uv_additional_y;
        pVertex.uv0 = uv;
  
  
        pVertex.uv0.z = pOutLineWidth; // z：定位为宽度
        pVertex.uv0.w = m_uivertex_alpha_max; // w：所有顶点中最大的透明度值

  
        // uv1 uv2 可用
        pVertex.uv1 = pUVOriginMin;     // uv1：定位为最小最大值数据
        pVertex.uv1.z = pUVOriginMax.x;
        pVertex.uv1.w = pUVOriginMax.y;

        pVertex.uv2 = this.OutlineColor; // uv2：定位为描边颜色

        return pVertex;
    }


    private static float _Min(float pA, float pB, float pC)
    {
        return Mathf.Min(Mathf.Min(pA, pB), pC);
    }


    private static float _Max(float pA, float pB, float pC)
    {
        return Mathf.Max(Mathf.Max(pA, pB), pC);
    }


    private static Vector2 _Min(Vector2 pA, Vector2 pB, Vector2 pC)
    {
        return new Vector2(_Min(pA.x, pB.x, pC.x), _Min(pA.y, pB.y, pC.y));
    }


    private static Vector2 _Max(Vector2 pA, Vector2 pB, Vector2 pC)
    {
        return new Vector2(_Max(pA.x, pB.x, pC.x), _Max(pA.y, pB.y, pC.y));
    }
}
```

</details>

##### 后处理Feature

<details>
	<summary>URP_Feature_Outline3D</summary>

```cs
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class URP_Feature_Outline3D : ScriptableRendererFeature
{
    class Outline3DRenderPass : ScriptableRenderPass
    {
        private static readonly List<ShaderTagId> s_shaderTagIds = new List<ShaderTagId>()
        {
            new ShaderTagId('UniversalForward'),
            new ShaderTagId('UniversalForwardOnly'),
            new ShaderTagId('SRPDefaultUnlit')
        };
        private static readonly int s_shaderProperty_outline3d = Shader.PropertyToID('_Outline3D');



        private readonly Material m_outline_material;
        private readonly FilteringSettings m_filteringSettings;
        private readonly MaterialPropertyBlock m_materialPropertyBlock;
        private RTHandle m_outline_rtHandle;


        public Outline3DRenderPass(Material material)
        {
            // Configures where the render pass should be injected.
            renderPassEvent = RenderPassEvent.AfterRenderingPostProcessing;
        
            m_outline_material = material;
            m_filteringSettings = new FilteringSettings(RenderQueueRange.all, renderingLayerMask: 0b10);
            m_materialPropertyBlock = new MaterialPropertyBlock();
        }


        public void Dispose()
        {
            m_outline_rtHandle?.Release();
            m_outline_rtHandle = null;
        
        }





        // This method is called before executing the render pass.
        // It can be used to configure render targets and their clear state. Also to create temporary render target textures.
        // When empty this render pass will render to the active camera render target.
        // You should never call CommandBuffer.SetRenderTarget. Instead call <c>ConfigureTarget</c> and <c>ConfigureClear</c>.
        // The render pipeline will ensure target setup and clearing happens in a performant manner.
        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)
        {

            var desc_camera = renderingData.cameraData.cameraTargetDescriptor;
            desc_camera.msaaSamples = 1;
            desc_camera.depthBufferBits = 0;
            desc_camera.colorFormat = RenderTextureFormat.ARGB32;
            RenderingUtils.ReAllocateIfNeeded(ref m_outline_rtHandle, desc_camera, name: '_Outline3D');
        }

        // Here you can implement the rendering logic.
        // Use <c>ScriptableRenderContext</c> to issue drawing commands or execute command buffers
        // https://docs.unity3d.com/ScriptReference/Rendering.ScriptableRenderContext.html
        // You don't have to call ScriptableRenderContext.submit, the render pipeline will call it at specific points in the pipeline.
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
        {
            var cmd = CommandBufferPool.Get('Outline3D CMD');

            // CMD
            cmd.SetRenderTarget(m_outline_rtHandle);
            cmd.ClearRenderTarget(true, true, Color.clear);


            var draw_settings = CreateDrawingSettings(s_shaderTagIds, ref renderingData, SortingCriteria.None);
            RendererListParams rendererListParams = new RendererListParams(renderingData.cullResults, draw_settings, m_filteringSettings);
            var list_draw = context.CreateRendererList(ref rendererListParams);
            cmd.DrawRendererList(list_draw);
        
        
            // cmd.SetRenderTarget(renderingData.cameraData.renderer.cameraColorTargetHandle);
            // m_materialPropertyBlock.SetTexture(s_shaderProperty_outline3d, m_outline_rtHandle);
            // cmd.DrawProcedural(Matrix4x4.identity, m_outline_material, 0, MeshTopology.Triangles, 3, 1, m_materialPropertyBlock);
            m_outline_material.SetTexture(s_shaderProperty_outline3d, m_outline_rtHandle);
            Blitter.BlitCameraTexture(cmd, m_outline_rtHandle,renderingData.cameraData.renderer.cameraColorTargetHandle,m_outline_material,0);



            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }

        // Cleanup any allocated resources that were created during the execution of this render pass.
        //public override void OnCameraCleanup(CommandBuffer cmd)
        //{
        //}
    }






    [SerializeField] private Material m_OutlineMaterial;
    private Outline3DRenderPass m_Outline3DScriptablePass;

    private bool IsMaterialValid => m_OutlineMaterial && m_OutlineMaterial.shader && m_OutlineMaterial.shader.isSupported;


    /// <inheritdoc/>
    public override void Create()
    {
        if (!IsMaterialValid)
        {
            return;
        }

        m_Outline3DScriptablePass = new Outline3DRenderPass(m_OutlineMaterial);
    }

    // Here you can inject one or multiple render passes in the renderer.
    // This method is called when setting up the renderer once per-camera.
    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
    {
        if (m_Outline3DScriptablePass == null)
        {
            return;
        }


        renderer.EnqueuePass(m_Outline3DScriptablePass);
    }


    protected override void Dispose(bool disposing)
    {
        m_Outline3DScriptablePass?.Dispose();
    }

}
```

</details>

<details>
	<summary>Outline3D</summary>

```hlsl
Shader 'URP/Outline3D'
{
    Properties
    {
        _OutlineColor ('Outline Color', Color) = (1, 1, 1, 1)
        _OutlineWidth ('Outline Width', Range(0, 0.01)) = 0.001
    }

    SubShader
    {
        Tags
        {
            'RenderType' = 'Opaque'
            'RenderPipeline' = 'UniversalPipeline'
            'Queue' = 'Geometry'
        }
        LOD 100
        
        ZWrite Off
        Cull Off
        Blend SrcAlpha OneMinusSrcAlpha

        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'
            #include 'Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl'


            struct Attributes
            {
                uint vertex_id : SV_VERTEXID;
            };

            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                half2 uv : TEXCOORD;
                half2 offsets[8] : TEXCOORD1;
            };


            TEXTURE2D_X(_Outline3D);
            SAMPLER(sampler_linear_clamp_Outline3D);

            CBUFFER_START(UnityPerMaterial)
            half4 _OutlineColor;
            float _OutlineWidth;
            CBUFFER_END


            Varyings vert(Attributes IN)
            {
                Varyings Output;
                Output.positionCS = GetFullScreenTriangleVertexPosition(IN.vertex_id);
                Output.uv = GetFullScreenTriangleTexCoord(IN.vertex_id);

                const half ratio_w_h = _ScreenParams.x / _ScreenParams.y;
                const float multipty_num_2 = 0.707; // sprt(2) / 2

                Output.offsets[0] = half2(-1, ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[1] = half2(0, ratio_w_h) * _OutlineWidth;
                Output.offsets[2] = half2(1, ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[3] = half2(-1, 0) * _OutlineWidth;
                
                Output.offsets[4] = half2(1, 0) * _OutlineWidth;
                Output.offsets[5] = half2(-1, -ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[6] = half2(0, -ratio_w_h) * _OutlineWidth;
                Output.offsets[7] = half2(1, -ratio_w_h) * _OutlineWidth * multipty_num_2;

                return Output;
            }



            half4 frag(Varyings IN) : SV_Target
            {
                const half kernelX[8] =
                {
                    - 1, 0, 1,
                    - 2, 2,
                    - 1, 0, 1
                };

                const half kernelY[8] =
                {
                    - 1, -2, -1,
                    0, 0,
                    1, 2, 1
                };


                half gx = 0;
                half gy = 0;
                half multiply_num = 0;

                for (int i = 0; i < 8; i++)
                {
                    multiply_num = SAMPLE_TEXTURE2D_X(_Outline3D, sampler_linear_clamp_Outline3D, IN.uv + IN.offsets[i]).a;
                    gx += multiply_num * kernelX[i];
                    gy += multiply_num * kernelY[i];
                }

                const half _a = SAMPLE_TEXTURE2D_X(_Outline3D, sampler_linear_clamp_Outline3D, IN.uv).a;
                half4 col = _OutlineColor;
                col.a = saturate(abs(gx) + abs(gy)) * (1 - _a);

                
                return col;
            }

            ENDHLSL
        }
    }
}
```

</details>

##### 后处理Feature2

<details>
	<summary>URP_Feature_Outline3D_2</summary>

```cs
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.RendererUtils;
using UnityEngine.Rendering.Universal;
using UnityEngine.Serialization;

public class URP_Feature_Outline3D_2 : ScriptableRendererFeature
{
    private class Outline3DRenderPass : ScriptableRenderPass
    {
        private static readonly List<ShaderTagId> s_shaderTagIds = new List<ShaderTagId>()
        {
            new ShaderTagId('UniversalForward'),
            new ShaderTagId('UniversalForwardOnly'),
            new ShaderTagId('SRPDefaultUnlit')
        };
        
        
        private readonly Material m_outline_material;
        private readonly Color m_outlineColor = Color.yellow;
        private readonly float m_downSampleScale = 0.5f; 
        private readonly int m_blurIterations = 1; 
        private readonly float m_blurWidth = 1.0f;
        
        
        
        private readonly FilteringSettings m_filteringSettings;
        private readonly MaterialPropertyBlock m_materialPropertyBlock;
        
        private RTHandle m_outline_rtHandle;
        private RTHandle m_temp_downsample_rtHandle;
        private RTHandle m_temp_blurRt;

        public Outline3DRenderPass(Material material,Color outlineColor,float downSampleScale,int blurIterations,float blurWidth)
        {
            // Configures where the render pass should be injected.
            renderPassEvent = RenderPassEvent.AfterRenderingPostProcessing;

            m_outline_material = material;
            m_outlineColor = outlineColor;
            m_downSampleScale = downSampleScale;
            m_blurIterations = blurIterations;
            m_blurWidth = blurWidth;
            
            m_filteringSettings = new FilteringSettings(RenderQueueRange.all, renderingLayerMask: 0b10);
            m_materialPropertyBlock = new MaterialPropertyBlock();
        }


        public void Dispose()
        {
            m_outline_rtHandle?.Release();
            m_outline_rtHandle = null;
            m_temp_blurRt?.Release();
            m_temp_blurRt = null;
            m_temp_downsample_rtHandle?.Release();
            m_temp_downsample_rtHandle = null;
        }




        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)
        {

            var desc_camera = renderingData.cameraData.cameraTargetDescriptor;
            desc_camera.msaaSamples = 1;
            desc_camera.depthBufferBits = 0;
            desc_camera.colorFormat = RenderTextureFormat.ARGB32;
            RenderingUtils.ReAllocateIfNeeded(ref m_outline_rtHandle, desc_camera, name: '_Outline3D');
            
            Vector2 scaleFactor = new Vector2(m_downSampleScale, m_downSampleScale);
            RenderingUtils.ReAllocateIfNeeded(ref m_temp_downsample_rtHandle,scaleFactor,desc_camera ,name: '_TempDownsample',filterMode:FilterMode.Bilinear);
            RenderingUtils.ReAllocateIfNeeded(ref m_temp_blurRt,scaleFactor,desc_camera ,name: '_TempBlur',filterMode:FilterMode.Bilinear);
        }
        
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
        {
            var cameraData = renderingData.cameraData;
            if (cameraData.camera.cameraType != CameraType.Game)
                return;

            if (m_outline_material == null)
                return;
            
            
            
            
            var cmd = CommandBufferPool.Get('Outline3D CMD');

            // CMD
            cmd.SetRenderTarget(m_temp_downsample_rtHandle);
            cmd.ClearRenderTarget(true, true, Color.clear);
            
            cmd.SetRenderTarget(m_temp_blurRt);
            cmd.ClearRenderTarget(true, true, Color.clear);
            
            cmd.SetRenderTarget(m_outline_rtHandle);
            cmd.ClearRenderTarget(true, true, Color.clear);


            var draw_settings = CreateDrawingSettings(s_shaderTagIds, ref renderingData, SortingCriteria.None);
            RendererListParams rendererListParams = new RendererListParams(renderingData.cullResults, draw_settings, m_filteringSettings);
            var list_draw = context.CreateRendererList(ref rendererListParams);
            cmd.DrawRendererList(list_draw);

            
            
            
            // Pass0
            m_outline_material.SetColor('_OutlineColor', m_outlineColor);
            Blitter.BlitCameraTexture(cmd, m_outline_rtHandle,m_outline_rtHandle,m_outline_material,0);
            m_outline_material.SetTexture('_OutlineColorTex', m_outline_rtHandle);

            
            
            // Pass1
            m_outline_material.SetFloat('_BlurWidth', m_blurWidth);
            for (int i = 0; i < m_blurIterations; ++i)
            {
                if (i == 0)
                {
                    Blitter.BlitCameraTexture(cmd, m_outline_rtHandle,m_temp_downsample_rtHandle,m_outline_material,1);
                    Blitter.BlitCameraTexture(cmd, m_temp_downsample_rtHandle,m_temp_blurRt,m_outline_material,1);
                }
                else
                {
                    Blitter.BlitCameraTexture(cmd, m_temp_blurRt,m_temp_downsample_rtHandle,m_outline_material,1);
                    Blitter.BlitCameraTexture(cmd, m_temp_downsample_rtHandle,m_temp_blurRt,m_outline_material,1);
                }
            }
            
            

            // Pass2
            m_outline_material.SetTexture('_BlurTex', m_temp_blurRt);
            
            
            RTHandle targetRT = cameraData.renderer.cameraColorTargetHandle;
            Blitter.BlitCameraTexture(cmd, targetRT,targetRT,m_outline_material,2);
            
            
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }

        
        public override void OnCameraCleanup(CommandBuffer cmd)
        {
            
        }
    }






    [SerializeField] private Material m_OutlineMaterial;
    public Color m_outlineColor = Color.yellow;

    [Range(0.1f, 1)]
    public float m_downSampleScale = 0.5f;                 // 降采样比例
    [Range(0, 4)]
    public int m_blurIterations = 1;                  // 均值糊迭代次数
    [FormerlySerializedAs('m_blurRadius')] [Range (0.2f, 10.0f)]
    public float m_blurWidth = 1.0f;
    
    private bool IsMaterialValid => m_OutlineMaterial && m_OutlineMaterial.shader && m_OutlineMaterial.shader.isSupported;

    
    
    
    private Outline3DRenderPass m_Outline3DScriptablePass;
    

    /// <inheritdoc/>
    public override void Create()
    {
        if (!IsMaterialValid)
        {
            return;
        }

        m_Outline3DScriptablePass = new Outline3DRenderPass(m_OutlineMaterial,m_outlineColor,m_downSampleScale,m_blurIterations,m_blurWidth);
    }
    
    
    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
    {
        if (m_Outline3DScriptablePass == null)
        {
            return;
        }

        if (renderingData.cameraData.cameraType == CameraType.Game)
        {
            renderer.EnqueuePass(m_Outline3DScriptablePass);
        }
    }


    protected override void Dispose(bool disposing)
    {
        m_Outline3DScriptablePass?.Dispose();
    }

}
```

</details>

<details>
	<summary>PostEffectOutline3D</summary>

```hlsl
Shader 'URP/PostEffectOutline3D'
{
    Properties
    {
    	[PerRendererData]_OutlineColor ('Outline Color',Color) = (1,1,1,1)
    	[PerRendererData]_BlurRadius('Blur Width',Float) = 1
    }
    SubShader
    {
        Tags
        {
            'RenderType'='Opaque'
            'RenderPipeline'='UniversalPipeline'
            'IgnoreProjector'='true'
        	'Queue' = 'Geometry'
        }
        LOD 100
		Cull Off 
		ZWrite Off
	    Blend SrcAlpha OneMinusSrcAlpha
        
        HLSLINCLUDE
        
        #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'
        #include 'Packages/com.unity.render-pipelines.core/Runtime/Utilities/Blit.hlsl'
        
        TEXTURE2D_X(_CameraOpaqueTexture);
        TEXTURE2D_X(_OutlineColorTex);
        TEXTURE2D_X(_BlurTex);
        SAMPLER(sampler_linear_clamp_CameraOpaqueTexture);

        half4 _BlitTexture_TexelSize;
        CBUFFER_START(UnityPerMaterial)
            half4 _OutlineColor;
		    float _BlurWidth;
        CBUFFER_END


        struct appdata_img
        {
	        half4 vertex : POSITION;
        	half2 texcoord : TEXCOORD0;
        };

        
        struct v2f
		{
			float4 pos : SV_POSITION;
			half2 uv_ : TEXCOORD0;
			half4 uv1 : TEXCOORD3;
			half4 uv2 : TEXCOORD4;
			half4 uv3 : TEXCOORD5;
			half4 uv4 : TEXCOORD6;
		};
        
        

        // 均值模糊
        // ---------------------------【顶点着色器】---------------------------
        v2f vert_average(appdata_img v,uint vid : SV_VertexID)  
        {  
            v2f o;  
            o.pos = GetFullScreenTriangleVertexPosition(vid); //TransformObjectToHClip(v.vertex);  
            //uv坐标  
            o.uv_ = GetFullScreenTriangleTexCoord(vid); //v.texcoord.xy;  
            //计算周围的8个uv坐标
            o.uv1.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(1, 0) * _BlurWidth;  
            o.uv1.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(-1, 0) * _BlurWidth;
            
            o.uv2.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(0, 1) * _BlurWidth;
            o.uv2.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(0, -1) * _BlurWidth;
            
            o.uv3.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(1, 1) * _BlurWidth;
            o.uv3.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(-1, 1) * _BlurWidth;
            
            o.uv4.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(1, -1) * _BlurWidth;
            o.uv4.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(-1, -1) * _BlurWidth;
            return o;  
        }  
        
        // ---------------------------【片元着色器】---------------------------
        half4 frag_average(v2f i) : SV_Target  
        {  
            half4 color = half4(0,0,0,0);  
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv1.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv1.zw);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv2.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv2.zw);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv3.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv3.zw);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv4.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv4.zw);
            // 取平均值
            return color / 9;
        }
        
        
        ENDHLSL
        
        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert
			#pragma fragment frag
            
            v2f vert (appdata_img v,uint vid : SV_VertexID)
            {
                v2f o;
				o.uv_ = GetFullScreenTriangleTexCoord(vid); //v.texcoord;
        		o.pos = GetFullScreenTriangleVertexPosition(vid); //TransformObjectToHClip(v.vertex);
                return o;
            }

            half4 frag (v2f i) : SV_Target
            {
            	half4 col = SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
            	clip(col.r - 0.1f);
            	return _OutlineColor;
            }
            
           ENDHLSL
        }


        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert_average
			#pragma fragment frag_average
            
            ENDHLSL
        }




        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert;
            #pragma fragment frag;

            v2f vert(appdata_img v,uint vid : SV_VertexID)
            {
                v2f o;
                o.pos = GetFullScreenTriangleVertexPosition(vid); //TransformObjectToHClip(v.vertex);
                o.uv_ = GetFullScreenTriangleTexCoord(vid); //v.texcoord;
                return o;
            }
            

			half4 frag(v2f i) : SV_Target
			{
				half4 scene = SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
				half4 blur = SAMPLE_TEXTURE2D_X(_BlurTex, sampler_linear_clamp_CameraOpaqueTexture,i.uv_);
				half4 outlieColor = SAMPLE_TEXTURE2D_X(_OutlineColorTex,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
				half4 o = outlieColor - blur;

				half sign = step(0.01h,o.a);
				half4 colMix = lerp(scene,_OutlineColor,o.a);
				return scene * (1-sign) + sign * colMix;
			}
            
            ENDHLSL
        }
        

    }
}

```



</details>
。">
<meta property="og:title" content="URP描边效果">
<meta property="og:description" content="##### 法线外扩/视口夹角

<details>
    <summary>Outline3DOutExternal</summary>

```hlsl
Shader 'URP/Outline3DOutExternal'
{
    Properties
    {
        _MainTex ('Texture', 2D) = 'white' {}
        _OutlineColor ('Color',Color) = (1,1,1,1)
        _OutlineWidth ('Outline Width',Range(0,0.1)) = 0.1
        _OutlinePowerIn ('Outline PowerIn',Range(0.01,10)) = 1
    }
    SubShader
    {
  


        Pass
        {
            Name 'Outline3D_Inside'
  
            Tags
            {
                'RenderType'='Opaque'
                'Queue'='Transparent'
                'RenderPipeline'='UniversalPipeline'
                'LightMode'='UniversalForward'
            }
            LOD 100
            Blend SrcAlpha OneMinusSrcAlpha

            HLSLPROGRAM
  
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            #pragma vertex vert;
            #pragma fragment frag;
  
            TEXTURE2D_X(_MainTex);
            SAMPLER(sampler_linear_clamp_MainTex);

            CBUFFER_START(UnityPerMaterial)
                half4 _OutlineColor;
                half _OutlinePowerIn;
            CBUFFER_END
  
            struct Varyings
            {
                half4 position : SV_POSITION;
                half2 uv : TEXCOORD0;
                half3 normal_world : TEXCOORD1;
                half3 position_world : TEXCOORD2;
            };


            Varyings vert(half2 uv : TEXCOORD0,half4 position : POSITION,half4 normal : NORMAL)
            {
                Varyings OUT;
                OUT.position_world = mul(GetObjectToWorldMatrix(),position);
                OUT.normal_world = TransformObjectToWorldNormal(normal);
                OUT.position = TransformObjectToHClip(position);
                OUT.uv = uv;
                return OUT;
            }


            half4 frag(Varyings IN) : SV_Target
            {
                half3 direction_view = normalize(GetCameraPositionWS() - (IN.position_world));
                half v = dot(direction_view,IN.normal_world);
                v = 1 - saturate(v);
                v = pow(v,_OutlinePowerIn);
  
                half4 col = SAMPLE_TEXTURE2D_X(_MainTex,sampler_linear_clamp_MainTex,IN.uv);
                return lerp(col,_OutlineColor,v);
            }
  
            ENDHLSL
        }
  

        Pass
        {
            Name 'Outline3D_Swell'
  
            Tags
            {
                'RenderType'='Opaque'
                'Queue'='Transparent'
                'RenderPipeline'='UniversalPipeline'
                'LightMode'='SRPDefaultUnlit'
            }
            LOD 100
            Blend SrcAlpha OneMinusSrcAlpha
            Cull Front

            HLSLPROGRAM
  
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            #pragma vertex vert;
            #pragma fragment frag;


            TEXTURE2D_X(_MainTex);
            SAMPLER(sampler_linear_clamp_MainTex);

            CBUFFER_START(UnityPerMaterial)
                half4 _OutlineColor;
                half _OutlineWidth;
            CBUFFER_END
  
            struct Varyings
            {
                half4 position : SV_POSITION;
                half2 uv : TEXCOORD0;
            };


            Varyings vert(half2 uv : TEXCOORD0,half4 position : POSITION,half4 normal : NORMAL)
            {
                Varyings OUT;
                position.xyz += normal * _OutlineWidth;
                OUT.position = TransformObjectToHClip(position);
                OUT.uv = uv;
                return OUT;
            }


            half4 frag(Varyings IN) : SV_Target
            {
                return _OutlineColor;
            }
  
            ENDHLSL
        }
    }

    Fallback 'Hidden/Universal Render Pipeline/FallbackError'
}
```

</details>

##### UI描边(配合C#)

<details>
	<summary>OutlineUI</summary>

```hlsl
Shader 'URP/OutlineUI'
{
    Properties
    {
        [PerRendererData]_MainTex ('Main Texture', 2D) = 'white' { }
        [HideInInspector]_Color ('Tint', Color) = (1, 1, 1, 1)

        [HideInInspector]_StencilComp ('Stencil Comparison', Float) = 8
        [HideInInspector]_Stencil ('Stencil ID', Float) = 0
        [HideInInspector]_StencilOp ('Stencil Operation', Float) = 0
        [HideInInspector]_StencilWriteMask ('Stencil Write Mask', Float) = 255
        [HideInInspector]_StencilReadMask ('Stencil Read Mask', Float) = 255

        [HideInInspector]_ColorMask ('Color Mask', Float) = 15

        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip ('Use Alpha Clip', Float) = 0
        _AlphaClipThreshold ('Alpha Clip Threshold',Range(0,1)) = 0.001
        // 注意：Softness属性这里定义只是为了Material Inspector显示，
        // 实际值将由RectMask2D组件通过MaterialPropertyBlock动态覆盖
        _Softness('Softness', Vector) = (0, 0, 0, 0)
    }

    SubShader
    {
        Tags
        {
            'Queue' = 'Transparent'
            'IgnoreProjector' = 'True'
            'RenderType' = 'Transparent'
            'PreviewType' = 'Plane'
            'CanUseSpriteAtlas' = 'True'
            'RenderPipeline' = 'UniversalPipeline'
        }
  

        Pass
        {
            Name 'UIOutlineEx'
  
            Stencil
            {
                Ref [_Stencil]
                Comp [_StencilComp]
                Pass [_StencilOp]
                ReadMask [_StencilReadMask]
                WriteMask [_StencilWriteMask]
            }
  
            Cull Off
            Lighting Off
            ZWrite Off
            ZTest [unity_GUIZTestMode]
            Blend SrcAlpha OneMinusSrcAlpha
            ColorMask [_ColorMask]

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag


            #pragma multi_compile_local _ UNITY_UI_CLIP_RECT
            #pragma multi_compile_local _ UNITY_UI_ALPHACLIP
  
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            half4 _ClipRect;


            CBUFFER_START(UnityPerMaterial)
            half4 _Color;
            float4 _MainTex_TexelSize;
            half4 _Softness;
            half _AlphaClipThreshold;
            CBUFFER_END

            half4 _TextureSampleAdd;

            struct appdata
            {
                float4 vertex : POSITION;
                float4 texcoord : TEXCOORD0;
                float4 uv1 : TEXCOORD1;
                float4 uv2 : TEXCOORD2;
                half4 color : COLOR;
            };


            struct v2f
            {
                float4 vertex : SV_POSITION;
                float4 texcoord : TEXCOORD0;
                float4 uv1 : TEXCOORD1;
                float4 uv2 : TEXCOORD2;
                half4 color : COLOR;

                half4 objPosition : TEXCOORD3;
            };

            v2f vert(appdata IN)
            {
                v2f o;
  
                o.vertex = TransformObjectToHClip(IN.vertex.xyz);
                o.texcoord = IN.texcoord;
                o.color = IN.color * _Color;
                o.uv1 = IN.uv1;
                o.uv2 = IN.uv2;

                o.objPosition = IN.vertex;
                return o;
            }

            half IsInRect(float2 pPos, float2 pClipRectMin, float2 pClipRectMax)
            {
                pPos = step(pClipRectMin, pPos) * step(pPos, pClipRectMax);
                return pPos.x * pPos.y;
            }

            half SampleAlpha(int pIndex, v2f IN)
            {
                const half sinArray[12] =
                {
                    0, 0.5, 0.866, 1, 0.866, 0.5, 0, -0.5, -0.866, -1, -0.866, -0.5
                };
                const half cosArray[12] =
                {
                    1, 0.866, 0.5, 0, -0.5, -0.866, -1, -0.866, -0.5, 0, 0.5, 0.866
                };
                float2 pos = IN.texcoord.xy + _MainTex_TexelSize.xy * float2(cosArray[pIndex], sinArray[pIndex]) * IN.texcoord.z;
                half pos_uv_col_a = (SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, pos) + _TextureSampleAdd).w;
                return IsInRect(pos, IN.uv1.xy, IN.uv1.zw) * pos_uv_col_a * IN.uv2.w;
            }
  
            half4 frag(v2f IN) : SV_Target
            {
                half4 color = (SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.texcoord.xy) + _TextureSampleAdd) * IN.color;

  
                if (all(IN.texcoord.z))
                {
                    half sign_a = IsInRect(IN.texcoord.xy, IN.uv1.xy, IN.uv1.zw);
                    color.a *= sign_a;
                    half4 val = half4(IN.uv2.rgb, 0);

                    val.w += SampleAlpha(0, IN);
                    val.w += SampleAlpha(1, IN);
                    val.w += SampleAlpha(2, IN);
                    val.w += SampleAlpha(3, IN);
                    val.w += SampleAlpha(4, IN);
                    val.w += SampleAlpha(5, IN);
                    val.w += SampleAlpha(6, IN);
                    val.w += SampleAlpha(7, IN);
                    val.w += SampleAlpha(8, IN);
                    val.w += SampleAlpha(9, IN);
                    val.w += SampleAlpha(10, IN);
                    val.w += SampleAlpha(11, IN);
                    val.w = saturate(val.w);

                    val.w *= IN.texcoord.w;
                    color = lerp(val, color, color.a) * val.w + color * (1 - val.w);
                }


               // 2. --- 核心：应用自定义的RectMask2D裁剪（带软边缘）---
                #if UNITY_UI_CLIP_RECT
                // 2.1 计算片元到裁剪矩形四条边的距离
                half2 minDist = (IN.objPosition.xy - _ClipRect.xy);
                half2 maxDist = (_ClipRect.zw - IN.objPosition.xy);
                half2 edgeDistance = min(minDist, maxDist); // 对于矩形内的点，这个值是正的

                // 2.2 计算软边缘因子
                // saturate(x / softness) ：
                // - 当 x > softness：结果 >= 1，完全保留
                // - 当 0 < x < softness：结果在 0 到 1 之间，平滑过渡
                // - 当 x < 0：结果为 0，完全裁剪
                // 使用max(softness, 0.001)避免除以零
                half2 softnessFactor = saturate(edgeDistance / max(_Softness.xy, 0.001));

                // 2.3 综合两个方向的因子（取最小值，这样任何一个方向出界都会导致裁剪）
                half finalAlphaFactor = softnessFactor.x * softnessFactor.y;

                // 2.4 将裁剪因子应用到最终颜色的Alpha通道
                color.a *= finalAlphaFactor;
                #endif

  
                #if UNITY_UI_ALPHACLIP
                    clip(color.a - _AlphaClipThreshold);
                #endif


                return color;
            }

  
            ENDHLSL
        }
    }
}
```

</details>

<details>
	<summary>UIOutlineEx</summary>

```cs
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

/// <summary>
/// UGUI描边
/// </summary>
public class UIOutlineEx : BaseMeshEffect
{
    private static List<UIVertex> m_VetexList = new List<UIVertex>();

    // 公开变量
    public Color OutlineColor = Color.black;
    [Range(0.01f, 6)] public float OutlineWidth = 1;
    [SerializeField] private Material m_outlineMaterial;
    [SerializeField] private bool m_DrawOutline;

    // 私有变量
    private float m_uivertex_alpha_max = 0;
    private CanvasGroup[] m_canvasGroups;
    private float m_canvasGroups_alphamul = 1;


    public void SetDrawOutline(bool draw)
    {
        m_DrawOutline = draw;
    }
  
  
  
    protected override void Awake()
    {
        base.Awake();

        if (base.graphic)
        {
            if (base.graphic.canvas)
            {
                var v1 = base.graphic.canvas.additionalShaderChannels;
                var v2 = AdditionalCanvasShaderChannels.TexCoord1;
                if ((v1 & v2) != v2)
                {
                    base.graphic.canvas.additionalShaderChannels |= v2;
                }
                v2 = AdditionalCanvasShaderChannels.TexCoord2;
                if ((v1 & v2) != v2)
                {
                    base.graphic.canvas.additionalShaderChannels |= v2;
                }
            }
            this._Refresh();
        }
    }

    protected override void OnDestroy()
    {
        base.graphic.material = null;
    }


    protected override void OnEnable()
    {
        base.graphic.material = m_outlineMaterial;
        this._Refresh();
    }

    protected override void OnDisable()
    {
        base.graphic.material = null;
        this._Refresh();
    }

    protected override void Start()
    {
        base.graphic.material = m_outlineMaterial;
    }


    protected override void OnCanvasGroupChanged()
    {
        base.OnCanvasGroupChanged();
        if (m_canvasGroups == null) m_canvasGroups = GetComponentsInParent<CanvasGroup>();

        m_canvasGroups_alphamul = 1;
        for (int i = 0; i < m_canvasGroups.Length; i++)
        {
            m_canvasGroups_alphamul *= m_canvasGroups[i].alpha;
        }
        this._Refresh();
    }
  

    private void _Refresh()
    {
        base.graphic.SetVerticesDirty();
    }


    public override void ModifyMesh(VertexHelper vh)
    {
        if(!m_DrawOutline) return;
  
        vh.GetUIVertexStream(m_VetexList);

        m_uivertex_alpha_max = 0;
        for (int i = 0; i < m_VetexList.Count; i++)
        {
            var v = m_VetexList[i];
            if (v.color.a / 255f > m_uivertex_alpha_max) m_uivertex_alpha_max = v.color.a / 255f;
        }
        m_uivertex_alpha_max *= m_canvasGroups_alphamul;

        this._ProcessVertices();

        vh.Clear();
        vh.AddUIVertexTriangleStream(m_VetexList);
    }


    private void _ProcessVertices()
    {
        for (int i = 0, count = m_VetexList.Count - 3; i <= count; i += 3)
        {
            var v1 = m_VetexList[i];
            var v2 = m_VetexList[i + 1];
            var v3 = m_VetexList[i + 2];
  
  
  
            // 计算原顶点坐标中心点
            //
            var minX = _Min(v1.position.x, v2.position.x, v3.position.x);
            var minY = _Min(v1.position.y, v2.position.y, v3.position.y);
            var maxX = _Max(v1.position.x, v2.position.x, v3.position.x);
            var maxY = _Max(v1.position.y, v2.position.y, v3.position.y);
            var posCenter = new Vector2(minX + maxX, minY + maxY) * 0.5f;
  
  
  
            // 计算原始顶点坐标和UV的方向
            //
            Vector2 triX, triY, uvX, uvY;
            Vector2 pos1 = v1.position;
            Vector2 pos2 = v2.position;
            Vector2 pos3 = v3.position;
            if (Mathf.Abs(Vector2.Dot((pos2 - pos1).normalized, Vector2.right))
                > Mathf.Abs(Vector2.Dot((pos3 - pos2).normalized, Vector2.right)))
            {
                triX = pos2 - pos1;
                triY = pos3 - pos2;
                uvX = v2.uv0 - v1.uv0;
                uvY = v3.uv0 - v2.uv0;
            }
            else
            {
                triX = pos3 - pos2;
                triY = pos2 - pos1;
                uvX = v3.uv0 - v2.uv0;
                uvY = v2.uv0 - v1.uv0;
            }
  
  
  
            // 计算原始UV框
            var uvMin = _Min(v1.uv0, v2.uv0, v3.uv0);
            var uvMax = _Max(v1.uv0, v2.uv0, v3.uv0);

            // 为每个顶点设置新的Position和UV，并传入原始UV框
            v1 = _SetNewPosAndUV(v1, this.OutlineWidth, posCenter, triX, triY, uvX, uvY, uvMin, uvMax);
            v2 = _SetNewPosAndUV(v2, this.OutlineWidth, posCenter, triX, triY, uvX, uvY, uvMin, uvMax);
            v3 = _SetNewPosAndUV(v3, this.OutlineWidth, posCenter, triX, triY, uvX, uvY, uvMin, uvMax);


            // 应用设置后的UIVertex
            //
            m_VetexList[i] = v1;
            m_VetexList[i + 1] = v2;
            m_VetexList[i + 2] = v3;
        }
    }


    private UIVertex _SetNewPosAndUV(
        UIVertex pVertex, float pOutLineWidth,
        Vector2 pPosCenter,
        Vector2 pTriangleX, Vector2 pTriangleY,
        Vector2 pUVX, Vector2 pUVY,
        Vector2 pUVOriginMin, Vector2 pUVOriginMax)
    {
        // Position
        var pos = pVertex.position;
        var posXOffset = pos.x > pPosCenter.x ? pOutLineWidth : -pOutLineWidth;
        var posYOffset = pos.y > pPosCenter.y ? pOutLineWidth : -pOutLineWidth;
        pos.x += posXOffset;
        pos.y += posYOffset;
        pVertex.position = pos;
  
        // UV
        var uv = (Vector2)pVertex.uv0;
        var uv_additional_x = pUVX / pTriangleX.magnitude * posXOffset * (Vector2.Dot(pTriangleX, Vector2.right) > 0 ? 1 : -1);
        var uv_additional_y = pUVY / pTriangleY.magnitude * posYOffset * (Vector2.Dot(pTriangleY, Vector2.up) > 0 ? 1 : -1);
        uv += uv_additional_x;
        uv += uv_additional_y;
        pVertex.uv0 = uv;
  
  
        pVertex.uv0.z = pOutLineWidth; // z：定位为宽度
        pVertex.uv0.w = m_uivertex_alpha_max; // w：所有顶点中最大的透明度值

  
        // uv1 uv2 可用
        pVertex.uv1 = pUVOriginMin;     // uv1：定位为最小最大值数据
        pVertex.uv1.z = pUVOriginMax.x;
        pVertex.uv1.w = pUVOriginMax.y;

        pVertex.uv2 = this.OutlineColor; // uv2：定位为描边颜色

        return pVertex;
    }


    private static float _Min(float pA, float pB, float pC)
    {
        return Mathf.Min(Mathf.Min(pA, pB), pC);
    }


    private static float _Max(float pA, float pB, float pC)
    {
        return Mathf.Max(Mathf.Max(pA, pB), pC);
    }


    private static Vector2 _Min(Vector2 pA, Vector2 pB, Vector2 pC)
    {
        return new Vector2(_Min(pA.x, pB.x, pC.x), _Min(pA.y, pB.y, pC.y));
    }


    private static Vector2 _Max(Vector2 pA, Vector2 pB, Vector2 pC)
    {
        return new Vector2(_Max(pA.x, pB.x, pC.x), _Max(pA.y, pB.y, pC.y));
    }
}
```

</details>

##### 后处理Feature

<details>
	<summary>URP_Feature_Outline3D</summary>

```cs
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class URP_Feature_Outline3D : ScriptableRendererFeature
{
    class Outline3DRenderPass : ScriptableRenderPass
    {
        private static readonly List<ShaderTagId> s_shaderTagIds = new List<ShaderTagId>()
        {
            new ShaderTagId('UniversalForward'),
            new ShaderTagId('UniversalForwardOnly'),
            new ShaderTagId('SRPDefaultUnlit')
        };
        private static readonly int s_shaderProperty_outline3d = Shader.PropertyToID('_Outline3D');



        private readonly Material m_outline_material;
        private readonly FilteringSettings m_filteringSettings;
        private readonly MaterialPropertyBlock m_materialPropertyBlock;
        private RTHandle m_outline_rtHandle;


        public Outline3DRenderPass(Material material)
        {
            // Configures where the render pass should be injected.
            renderPassEvent = RenderPassEvent.AfterRenderingPostProcessing;
        
            m_outline_material = material;
            m_filteringSettings = new FilteringSettings(RenderQueueRange.all, renderingLayerMask: 0b10);
            m_materialPropertyBlock = new MaterialPropertyBlock();
        }


        public void Dispose()
        {
            m_outline_rtHandle?.Release();
            m_outline_rtHandle = null;
        
        }





        // This method is called before executing the render pass.
        // It can be used to configure render targets and their clear state. Also to create temporary render target textures.
        // When empty this render pass will render to the active camera render target.
        // You should never call CommandBuffer.SetRenderTarget. Instead call <c>ConfigureTarget</c> and <c>ConfigureClear</c>.
        // The render pipeline will ensure target setup and clearing happens in a performant manner.
        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)
        {

            var desc_camera = renderingData.cameraData.cameraTargetDescriptor;
            desc_camera.msaaSamples = 1;
            desc_camera.depthBufferBits = 0;
            desc_camera.colorFormat = RenderTextureFormat.ARGB32;
            RenderingUtils.ReAllocateIfNeeded(ref m_outline_rtHandle, desc_camera, name: '_Outline3D');
        }

        // Here you can implement the rendering logic.
        // Use <c>ScriptableRenderContext</c> to issue drawing commands or execute command buffers
        // https://docs.unity3d.com/ScriptReference/Rendering.ScriptableRenderContext.html
        // You don't have to call ScriptableRenderContext.submit, the render pipeline will call it at specific points in the pipeline.
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
        {
            var cmd = CommandBufferPool.Get('Outline3D CMD');

            // CMD
            cmd.SetRenderTarget(m_outline_rtHandle);
            cmd.ClearRenderTarget(true, true, Color.clear);


            var draw_settings = CreateDrawingSettings(s_shaderTagIds, ref renderingData, SortingCriteria.None);
            RendererListParams rendererListParams = new RendererListParams(renderingData.cullResults, draw_settings, m_filteringSettings);
            var list_draw = context.CreateRendererList(ref rendererListParams);
            cmd.DrawRendererList(list_draw);
        
        
            // cmd.SetRenderTarget(renderingData.cameraData.renderer.cameraColorTargetHandle);
            // m_materialPropertyBlock.SetTexture(s_shaderProperty_outline3d, m_outline_rtHandle);
            // cmd.DrawProcedural(Matrix4x4.identity, m_outline_material, 0, MeshTopology.Triangles, 3, 1, m_materialPropertyBlock);
            m_outline_material.SetTexture(s_shaderProperty_outline3d, m_outline_rtHandle);
            Blitter.BlitCameraTexture(cmd, m_outline_rtHandle,renderingData.cameraData.renderer.cameraColorTargetHandle,m_outline_material,0);



            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }

        // Cleanup any allocated resources that were created during the execution of this render pass.
        //public override void OnCameraCleanup(CommandBuffer cmd)
        //{
        //}
    }






    [SerializeField] private Material m_OutlineMaterial;
    private Outline3DRenderPass m_Outline3DScriptablePass;

    private bool IsMaterialValid => m_OutlineMaterial && m_OutlineMaterial.shader && m_OutlineMaterial.shader.isSupported;


    /// <inheritdoc/>
    public override void Create()
    {
        if (!IsMaterialValid)
        {
            return;
        }

        m_Outline3DScriptablePass = new Outline3DRenderPass(m_OutlineMaterial);
    }

    // Here you can inject one or multiple render passes in the renderer.
    // This method is called when setting up the renderer once per-camera.
    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
    {
        if (m_Outline3DScriptablePass == null)
        {
            return;
        }


        renderer.EnqueuePass(m_Outline3DScriptablePass);
    }


    protected override void Dispose(bool disposing)
    {
        m_Outline3DScriptablePass?.Dispose();
    }

}
```

</details>

<details>
	<summary>Outline3D</summary>

```hlsl
Shader 'URP/Outline3D'
{
    Properties
    {
        _OutlineColor ('Outline Color', Color) = (1, 1, 1, 1)
        _OutlineWidth ('Outline Width', Range(0, 0.01)) = 0.001
    }

    SubShader
    {
        Tags
        {
            'RenderType' = 'Opaque'
            'RenderPipeline' = 'UniversalPipeline'
            'Queue' = 'Geometry'
        }
        LOD 100
        
        ZWrite Off
        Cull Off
        Blend SrcAlpha OneMinusSrcAlpha

        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'
            #include 'Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl'


            struct Attributes
            {
                uint vertex_id : SV_VERTEXID;
            };

            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                half2 uv : TEXCOORD;
                half2 offsets[8] : TEXCOORD1;
            };


            TEXTURE2D_X(_Outline3D);
            SAMPLER(sampler_linear_clamp_Outline3D);

            CBUFFER_START(UnityPerMaterial)
            half4 _OutlineColor;
            float _OutlineWidth;
            CBUFFER_END


            Varyings vert(Attributes IN)
            {
                Varyings Output;
                Output.positionCS = GetFullScreenTriangleVertexPosition(IN.vertex_id);
                Output.uv = GetFullScreenTriangleTexCoord(IN.vertex_id);

                const half ratio_w_h = _ScreenParams.x / _ScreenParams.y;
                const float multipty_num_2 = 0.707; // sprt(2) / 2

                Output.offsets[0] = half2(-1, ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[1] = half2(0, ratio_w_h) * _OutlineWidth;
                Output.offsets[2] = half2(1, ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[3] = half2(-1, 0) * _OutlineWidth;
                
                Output.offsets[4] = half2(1, 0) * _OutlineWidth;
                Output.offsets[5] = half2(-1, -ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[6] = half2(0, -ratio_w_h) * _OutlineWidth;
                Output.offsets[7] = half2(1, -ratio_w_h) * _OutlineWidth * multipty_num_2;

                return Output;
            }



            half4 frag(Varyings IN) : SV_Target
            {
                const half kernelX[8] =
                {
                    - 1, 0, 1,
                    - 2, 2,
                    - 1, 0, 1
                };

                const half kernelY[8] =
                {
                    - 1, -2, -1,
                    0, 0,
                    1, 2, 1
                };


                half gx = 0;
                half gy = 0;
                half multiply_num = 0;

                for (int i = 0; i < 8; i++)
                {
                    multiply_num = SAMPLE_TEXTURE2D_X(_Outline3D, sampler_linear_clamp_Outline3D, IN.uv + IN.offsets[i]).a;
                    gx += multiply_num * kernelX[i];
                    gy += multiply_num * kernelY[i];
                }

                const half _a = SAMPLE_TEXTURE2D_X(_Outline3D, sampler_linear_clamp_Outline3D, IN.uv).a;
                half4 col = _OutlineColor;
                col.a = saturate(abs(gx) + abs(gy)) * (1 - _a);

                
                return col;
            }

            ENDHLSL
        }
    }
}
```

</details>

##### 后处理Feature2

<details>
	<summary>URP_Feature_Outline3D_2</summary>

```cs
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.RendererUtils;
using UnityEngine.Rendering.Universal;
using UnityEngine.Serialization;

public class URP_Feature_Outline3D_2 : ScriptableRendererFeature
{
    private class Outline3DRenderPass : ScriptableRenderPass
    {
        private static readonly List<ShaderTagId> s_shaderTagIds = new List<ShaderTagId>()
        {
            new ShaderTagId('UniversalForward'),
            new ShaderTagId('UniversalForwardOnly'),
            new ShaderTagId('SRPDefaultUnlit')
        };
        
        
        private readonly Material m_outline_material;
        private readonly Color m_outlineColor = Color.yellow;
        private readonly float m_downSampleScale = 0.5f; 
        private readonly int m_blurIterations = 1; 
        private readonly float m_blurWidth = 1.0f;
        
        
        
        private readonly FilteringSettings m_filteringSettings;
        private readonly MaterialPropertyBlock m_materialPropertyBlock;
        
        private RTHandle m_outline_rtHandle;
        private RTHandle m_temp_downsample_rtHandle;
        private RTHandle m_temp_blurRt;

        public Outline3DRenderPass(Material material,Color outlineColor,float downSampleScale,int blurIterations,float blurWidth)
        {
            // Configures where the render pass should be injected.
            renderPassEvent = RenderPassEvent.AfterRenderingPostProcessing;

            m_outline_material = material;
            m_outlineColor = outlineColor;
            m_downSampleScale = downSampleScale;
            m_blurIterations = blurIterations;
            m_blurWidth = blurWidth;
            
            m_filteringSettings = new FilteringSettings(RenderQueueRange.all, renderingLayerMask: 0b10);
            m_materialPropertyBlock = new MaterialPropertyBlock();
        }


        public void Dispose()
        {
            m_outline_rtHandle?.Release();
            m_outline_rtHandle = null;
            m_temp_blurRt?.Release();
            m_temp_blurRt = null;
            m_temp_downsample_rtHandle?.Release();
            m_temp_downsample_rtHandle = null;
        }




        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)
        {

            var desc_camera = renderingData.cameraData.cameraTargetDescriptor;
            desc_camera.msaaSamples = 1;
            desc_camera.depthBufferBits = 0;
            desc_camera.colorFormat = RenderTextureFormat.ARGB32;
            RenderingUtils.ReAllocateIfNeeded(ref m_outline_rtHandle, desc_camera, name: '_Outline3D');
            
            Vector2 scaleFactor = new Vector2(m_downSampleScale, m_downSampleScale);
            RenderingUtils.ReAllocateIfNeeded(ref m_temp_downsample_rtHandle,scaleFactor,desc_camera ,name: '_TempDownsample',filterMode:FilterMode.Bilinear);
            RenderingUtils.ReAllocateIfNeeded(ref m_temp_blurRt,scaleFactor,desc_camera ,name: '_TempBlur',filterMode:FilterMode.Bilinear);
        }
        
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
        {
            var cameraData = renderingData.cameraData;
            if (cameraData.camera.cameraType != CameraType.Game)
                return;

            if (m_outline_material == null)
                return;
            
            
            
            
            var cmd = CommandBufferPool.Get('Outline3D CMD');

            // CMD
            cmd.SetRenderTarget(m_temp_downsample_rtHandle);
            cmd.ClearRenderTarget(true, true, Color.clear);
            
            cmd.SetRenderTarget(m_temp_blurRt);
            cmd.ClearRenderTarget(true, true, Color.clear);
            
            cmd.SetRenderTarget(m_outline_rtHandle);
            cmd.ClearRenderTarget(true, true, Color.clear);


            var draw_settings = CreateDrawingSettings(s_shaderTagIds, ref renderingData, SortingCriteria.None);
            RendererListParams rendererListParams = new RendererListParams(renderingData.cullResults, draw_settings, m_filteringSettings);
            var list_draw = context.CreateRendererList(ref rendererListParams);
            cmd.DrawRendererList(list_draw);

            
            
            
            // Pass0
            m_outline_material.SetColor('_OutlineColor', m_outlineColor);
            Blitter.BlitCameraTexture(cmd, m_outline_rtHandle,m_outline_rtHandle,m_outline_material,0);
            m_outline_material.SetTexture('_OutlineColorTex', m_outline_rtHandle);

            
            
            // Pass1
            m_outline_material.SetFloat('_BlurWidth', m_blurWidth);
            for (int i = 0; i < m_blurIterations; ++i)
            {
                if (i == 0)
                {
                    Blitter.BlitCameraTexture(cmd, m_outline_rtHandle,m_temp_downsample_rtHandle,m_outline_material,1);
                    Blitter.BlitCameraTexture(cmd, m_temp_downsample_rtHandle,m_temp_blurRt,m_outline_material,1);
                }
                else
                {
                    Blitter.BlitCameraTexture(cmd, m_temp_blurRt,m_temp_downsample_rtHandle,m_outline_material,1);
                    Blitter.BlitCameraTexture(cmd, m_temp_downsample_rtHandle,m_temp_blurRt,m_outline_material,1);
                }
            }
            
            

            // Pass2
            m_outline_material.SetTexture('_BlurTex', m_temp_blurRt);
            
            
            RTHandle targetRT = cameraData.renderer.cameraColorTargetHandle;
            Blitter.BlitCameraTexture(cmd, targetRT,targetRT,m_outline_material,2);
            
            
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }

        
        public override void OnCameraCleanup(CommandBuffer cmd)
        {
            
        }
    }






    [SerializeField] private Material m_OutlineMaterial;
    public Color m_outlineColor = Color.yellow;

    [Range(0.1f, 1)]
    public float m_downSampleScale = 0.5f;                 // 降采样比例
    [Range(0, 4)]
    public int m_blurIterations = 1;                  // 均值糊迭代次数
    [FormerlySerializedAs('m_blurRadius')] [Range (0.2f, 10.0f)]
    public float m_blurWidth = 1.0f;
    
    private bool IsMaterialValid => m_OutlineMaterial && m_OutlineMaterial.shader && m_OutlineMaterial.shader.isSupported;

    
    
    
    private Outline3DRenderPass m_Outline3DScriptablePass;
    

    /// <inheritdoc/>
    public override void Create()
    {
        if (!IsMaterialValid)
        {
            return;
        }

        m_Outline3DScriptablePass = new Outline3DRenderPass(m_OutlineMaterial,m_outlineColor,m_downSampleScale,m_blurIterations,m_blurWidth);
    }
    
    
    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
    {
        if (m_Outline3DScriptablePass == null)
        {
            return;
        }

        if (renderingData.cameraData.cameraType == CameraType.Game)
        {
            renderer.EnqueuePass(m_Outline3DScriptablePass);
        }
    }


    protected override void Dispose(bool disposing)
    {
        m_Outline3DScriptablePass?.Dispose();
    }

}
```

</details>

<details>
	<summary>PostEffectOutline3D</summary>

```hlsl
Shader 'URP/PostEffectOutline3D'
{
    Properties
    {
    	[PerRendererData]_OutlineColor ('Outline Color',Color) = (1,1,1,1)
    	[PerRendererData]_BlurRadius('Blur Width',Float) = 1
    }
    SubShader
    {
        Tags
        {
            'RenderType'='Opaque'
            'RenderPipeline'='UniversalPipeline'
            'IgnoreProjector'='true'
        	'Queue' = 'Geometry'
        }
        LOD 100
		Cull Off 
		ZWrite Off
	    Blend SrcAlpha OneMinusSrcAlpha
        
        HLSLINCLUDE
        
        #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'
        #include 'Packages/com.unity.render-pipelines.core/Runtime/Utilities/Blit.hlsl'
        
        TEXTURE2D_X(_CameraOpaqueTexture);
        TEXTURE2D_X(_OutlineColorTex);
        TEXTURE2D_X(_BlurTex);
        SAMPLER(sampler_linear_clamp_CameraOpaqueTexture);

        half4 _BlitTexture_TexelSize;
        CBUFFER_START(UnityPerMaterial)
            half4 _OutlineColor;
		    float _BlurWidth;
        CBUFFER_END


        struct appdata_img
        {
	        half4 vertex : POSITION;
        	half2 texcoord : TEXCOORD0;
        };

        
        struct v2f
		{
			float4 pos : SV_POSITION;
			half2 uv_ : TEXCOORD0;
			half4 uv1 : TEXCOORD3;
			half4 uv2 : TEXCOORD4;
			half4 uv3 : TEXCOORD5;
			half4 uv4 : TEXCOORD6;
		};
        
        

        // 均值模糊
        // ---------------------------【顶点着色器】---------------------------
        v2f vert_average(appdata_img v,uint vid : SV_VertexID)  
        {  
            v2f o;  
            o.pos = GetFullScreenTriangleVertexPosition(vid); //TransformObjectToHClip(v.vertex);  
            //uv坐标  
            o.uv_ = GetFullScreenTriangleTexCoord(vid); //v.texcoord.xy;  
            //计算周围的8个uv坐标
            o.uv1.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(1, 0) * _BlurWidth;  
            o.uv1.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(-1, 0) * _BlurWidth;
            
            o.uv2.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(0, 1) * _BlurWidth;
            o.uv2.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(0, -1) * _BlurWidth;
            
            o.uv3.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(1, 1) * _BlurWidth;
            o.uv3.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(-1, 1) * _BlurWidth;
            
            o.uv4.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(1, -1) * _BlurWidth;
            o.uv4.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(-1, -1) * _BlurWidth;
            return o;  
        }  
        
        // ---------------------------【片元着色器】---------------------------
        half4 frag_average(v2f i) : SV_Target  
        {  
            half4 color = half4(0,0,0,0);  
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv1.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv1.zw);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv2.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv2.zw);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv3.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv3.zw);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv4.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv4.zw);
            // 取平均值
            return color / 9;
        }
        
        
        ENDHLSL
        
        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert
			#pragma fragment frag
            
            v2f vert (appdata_img v,uint vid : SV_VertexID)
            {
                v2f o;
				o.uv_ = GetFullScreenTriangleTexCoord(vid); //v.texcoord;
        		o.pos = GetFullScreenTriangleVertexPosition(vid); //TransformObjectToHClip(v.vertex);
                return o;
            }

            half4 frag (v2f i) : SV_Target
            {
            	half4 col = SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
            	clip(col.r - 0.1f);
            	return _OutlineColor;
            }
            
           ENDHLSL
        }


        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert_average
			#pragma fragment frag_average
            
            ENDHLSL
        }




        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert;
            #pragma fragment frag;

            v2f vert(appdata_img v,uint vid : SV_VertexID)
            {
                v2f o;
                o.pos = GetFullScreenTriangleVertexPosition(vid); //TransformObjectToHClip(v.vertex);
                o.uv_ = GetFullScreenTriangleTexCoord(vid); //v.texcoord;
                return o;
            }
            

			half4 frag(v2f i) : SV_Target
			{
				half4 scene = SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
				half4 blur = SAMPLE_TEXTURE2D_X(_BlurTex, sampler_linear_clamp_CameraOpaqueTexture,i.uv_);
				half4 outlieColor = SAMPLE_TEXTURE2D_X(_OutlineColorTex,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
				half4 o = outlieColor - blur;

				half sign = step(0.01h,o.a);
				half4 colMix = lerp(scene,_OutlineColor,o.a);
				return scene * (1-sign) + sign * colMix;
			}
            
            ENDHLSL
        }
        

    }
}

```



</details>
。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ogazen.github.io/post/URP-miao-bian-xiao-guo.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/68213482?v=4">
<title>URP描边效果</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">URP描边效果</h1>
<div class="title-right">
    <a href="https://ogazen.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/oGazen/ogazen.github.io/issues/10" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h5>法线外扩/视口夹角</h5>
<details>
    <summary>Outline3DOutExternal</summary>
<div class="highlight highlight-source-hlsl"><pre class="notranslate">Shader <span class="pl-s">"URP/Outline3DOutExternal"</span>
{
    Properties
    {
        <span class="pl-c1">_MainTex</span> (<span class="pl-s">"Texture"</span>, 2D) = <span class="pl-s">"white"</span> {}
        <span class="pl-c1">_OutlineColor</span> (<span class="pl-s">"Color"</span>,Color) = (<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>)
        <span class="pl-c1">_OutlineWidth</span> (<span class="pl-s">"Outline Width"</span>,<span class="pl-c1">Range</span>(<span class="pl-c1">0</span>,<span class="pl-c1">0.1</span>)) = <span class="pl-c1">0.1</span>
        <span class="pl-c1">_OutlinePowerIn</span> (<span class="pl-s">"Outline PowerIn"</span>,<span class="pl-c1">Range</span>(<span class="pl-c1">0.01</span>,<span class="pl-c1">10</span>)) = <span class="pl-c1">1</span>
    }
    SubShader
    {
  


        Pass
        {
            Name <span class="pl-s">"Outline3D_Inside"</span>
  
            Tags
            {
                <span class="pl-s">"RenderType"</span>=<span class="pl-s">"Opaque"</span>
                <span class="pl-s">"Queue"</span>=<span class="pl-s">"Transparent"</span>
                <span class="pl-s">"RenderPipeline"</span>=<span class="pl-s">"UniversalPipeline"</span>
                <span class="pl-s">"LightMode"</span>=<span class="pl-s">"UniversalForward"</span>
            }
            LOD <span class="pl-c1">100</span>
            Blend SrcAlpha OneMinusSrcAlpha

            HLSLPROGRAM
  
<span class="pl-k">            #include</span> <span class="pl-s">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"</span>

<span class="pl-k">            #pragma</span> vertex vert;
<span class="pl-k">            #pragma</span> fragment frag;
  
            <span class="pl-c1">TEXTURE2D_X</span>(_MainTex);
            <span class="pl-c1">SAMPLER</span>(sampler_linear_clamp_MainTex);

            <span class="pl-c1">CBUFFER_START</span>(UnityPerMaterial)
                <span class="pl-k">half4</span> _OutlineColor;
                <span class="pl-k">half</span> _OutlinePowerIn;
            CBUFFER_END
  
            <span class="pl-k">struct</span> Varyings
            {
                <span class="pl-k">half4</span> position : <span class="pl-c1">SV_POSITION</span>;
                <span class="pl-k">half2</span> uv : <span class="pl-c1">TEXCOORD0</span>;
                <span class="pl-k">half3</span> normal_world : <span class="pl-c1">TEXCOORD1</span>;
                <span class="pl-k">half3</span> position_world : <span class="pl-c1">TEXCOORD2</span>;
            };


            Varyings <span class="pl-c1">vert</span>(<span class="pl-k">half2</span> uv : <span class="pl-c1">TEXCOORD0</span>,<span class="pl-k">half4</span> position : <span class="pl-c1">POSITION</span>,<span class="pl-k">half4</span> normal : <span class="pl-c1">NORMAL</span>)
            {
                Varyings OUT;
                OUT.position_world = <span class="pl-c1">mul</span>(<span class="pl-c1">GetObjectToWorldMatrix</span>(),position);
                OUT.normal_world = <span class="pl-c1">TransformObjectToWorldNormal</span>(normal);
                OUT.position = <span class="pl-c1">TransformObjectToHClip</span>(position);
                OUT.uv = uv;
                <span class="pl-k">return</span> OUT;
            }


            <span class="pl-k">half4</span> <span class="pl-c1">frag</span>(Varyings IN) : <span class="pl-c1">SV_Target</span>
            {
                <span class="pl-k">half3</span> direction_view = <span class="pl-c1">normalize</span>(<span class="pl-c1">GetCameraPositionWS</span>() - (IN.position_world));
                <span class="pl-k">half</span> v = <span class="pl-c1">dot</span>(direction_view,IN.normal_world);
                v = <span class="pl-c1">1</span> - <span class="pl-c1">saturate</span>(v);
                v = <span class="pl-c1">pow</span>(v,_OutlinePowerIn);
  
                <span class="pl-k">half4</span> col = <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_MainTex,sampler_linear_clamp_MainTex,IN.uv);
                <span class="pl-k">return</span> <span class="pl-c1">lerp</span>(col,_OutlineColor,v);
            }
  
            ENDHLSL
        }
  

        Pass
        {
            Name <span class="pl-s">"Outline3D_Swell"</span>
  
            Tags
            {
                <span class="pl-s">"RenderType"</span>=<span class="pl-s">"Opaque"</span>
                <span class="pl-s">"Queue"</span>=<span class="pl-s">"Transparent"</span>
                <span class="pl-s">"RenderPipeline"</span>=<span class="pl-s">"UniversalPipeline"</span>
                <span class="pl-s">"LightMode"</span>=<span class="pl-s">"SRPDefaultUnlit"</span>
            }
            LOD <span class="pl-c1">100</span>
            Blend SrcAlpha OneMinusSrcAlpha
            Cull <span class="pl-c1">Front</span>

            HLSLPROGRAM
  
<span class="pl-k">            #include</span> <span class="pl-s">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"</span>

<span class="pl-k">            #pragma</span> vertex vert;
<span class="pl-k">            #pragma</span> fragment frag;


            <span class="pl-c1">TEXTURE2D_X</span>(_MainTex);
            <span class="pl-c1">SAMPLER</span>(sampler_linear_clamp_MainTex);

            <span class="pl-c1">CBUFFER_START</span>(UnityPerMaterial)
                <span class="pl-k">half4</span> _OutlineColor;
                <span class="pl-k">half</span> _OutlineWidth;
            CBUFFER_END
  
            <span class="pl-k">struct</span> Varyings
            {
                <span class="pl-k">half4</span> position : <span class="pl-c1">SV_POSITION</span>;
                <span class="pl-k">half2</span> uv : <span class="pl-c1">TEXCOORD0</span>;
            };


            Varyings <span class="pl-c1">vert</span>(<span class="pl-k">half2</span> uv : <span class="pl-c1">TEXCOORD0</span>,<span class="pl-k">half4</span> position : <span class="pl-c1">POSITION</span>,<span class="pl-k">half4</span> normal : <span class="pl-c1">NORMAL</span>)
            {
                Varyings OUT;
                position.xyz += normal * _OutlineWidth;
                OUT.position = <span class="pl-c1">TransformObjectToHClip</span>(position);
                OUT.uv = uv;
                <span class="pl-k">return</span> OUT;
            }


            <span class="pl-k">half4</span> <span class="pl-c1">frag</span>(Varyings IN) : <span class="pl-c1">SV_Target</span>
            {
                <span class="pl-k">return</span> _OutlineColor;
            }
  
            ENDHLSL
        }
    }

    Fallback <span class="pl-s">"Hidden/Universal Render Pipeline/FallbackError"</span>
}</pre></div>
</details>
<h5>UI描边(配合C#)</h5>
<details>
	<summary>OutlineUI</summary>
<div class="highlight highlight-source-hlsl"><pre class="notranslate">Shader <span class="pl-s">"URP/OutlineUI"</span>
{
    Properties
    {
        [PerRendererData]<span class="pl-c1">_MainTex</span> (<span class="pl-s">"Main Texture"</span>, 2D) = <span class="pl-s">"white"</span> { }
        [HideInInspector]<span class="pl-c1">_Color</span> (<span class="pl-s">"Tint"</span>, Color) = (<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)

        [HideInInspector]<span class="pl-c1">_StencilComp</span> (<span class="pl-s">"Stencil Comparison"</span>, Float) = <span class="pl-c1">8</span>
        [HideInInspector]<span class="pl-c1">_Stencil</span> (<span class="pl-s">"Stencil ID"</span>, Float) = <span class="pl-c1">0</span>
        [HideInInspector]<span class="pl-c1">_StencilOp</span> (<span class="pl-s">"Stencil Operation"</span>, Float) = <span class="pl-c1">0</span>
        [HideInInspector]<span class="pl-c1">_StencilWriteMask</span> (<span class="pl-s">"Stencil Write Mask"</span>, Float) = <span class="pl-c1">255</span>
        [HideInInspector]<span class="pl-c1">_StencilReadMask</span> (<span class="pl-s">"Stencil Read Mask"</span>, Float) = <span class="pl-c1">255</span>

        [HideInInspector]<span class="pl-c1">_ColorMask</span> (<span class="pl-s">"Color Mask"</span>, Float) = <span class="pl-c1">15</span>

        [<span class="pl-c1">Toggle</span>(UNITY_UI_ALPHACLIP)] <span class="pl-c1">_UseUIAlphaClip</span> (<span class="pl-s">"Use Alpha Clip"</span>, Float) = <span class="pl-c1">0</span>
        <span class="pl-c1">_AlphaClipThreshold</span> (<span class="pl-s">"Alpha Clip Threshold"</span>,<span class="pl-c1">Range</span>(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>)) = <span class="pl-c1">0.001</span>
        <span class="pl-c">// 注意：Softness属性这里定义只是为了Material Inspector显示，</span>
        <span class="pl-c">// 实际值将由RectMask2D组件通过MaterialPropertyBlock动态覆盖</span>
        <span class="pl-c1">_Softness</span>(<span class="pl-s">"Softness"</span>, Vector) = (<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>)
    }

    SubShader
    {
        Tags
        {
            <span class="pl-s">"Queue"</span> = <span class="pl-s">"Transparent"</span>
            <span class="pl-s">"IgnoreProjector"</span> = <span class="pl-s">"True"</span>
            <span class="pl-s">"RenderType"</span> = <span class="pl-s">"Transparent"</span>
            <span class="pl-s">"PreviewType"</span> = <span class="pl-s">"Plane"</span>
            <span class="pl-s">"CanUseSpriteAtlas"</span> = <span class="pl-s">"True"</span>
            <span class="pl-s">"RenderPipeline"</span> = <span class="pl-s">"UniversalPipeline"</span>
        }
  

        Pass
        {
            Name <span class="pl-s">"UIOutlineEx"</span>
  
            Stencil
            {
                Ref [_Stencil]
                Comp [_StencilComp]
                Pass [_StencilOp]
                ReadMask [_StencilReadMask]
                WriteMask [_StencilWriteMask]
            }
  
            Cull Off
            Lighting Off
            ZWrite Off
            ZTest [unity_GUIZTestMode]
            Blend SrcAlpha OneMinusSrcAlpha
            ColorMask [_ColorMask]

            HLSLPROGRAM
<span class="pl-k">            #pragma</span> vertex vert
<span class="pl-k">            #pragma</span> fragment frag


<span class="pl-k">            #pragma</span> multi_compile_local _ UNITY_UI_CLIP_RECT
<span class="pl-k">            #pragma</span> multi_compile_local _ UNITY_UI_ALPHACLIP
  
<span class="pl-k">            #include</span> <span class="pl-s">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"</span>

            <span class="pl-c1">TEXTURE2D</span>(_MainTex);
            <span class="pl-c1">SAMPLER</span>(sampler_MainTex);
            <span class="pl-k">half4</span> _ClipRect;


            <span class="pl-c1">CBUFFER_START</span>(UnityPerMaterial)
            <span class="pl-k">half4</span> _Color;
            <span class="pl-k">float4</span> _MainTex_TexelSize;
            <span class="pl-k">half4</span> _Softness;
            <span class="pl-k">half</span> _AlphaClipThreshold;
            CBUFFER_END

            <span class="pl-k">half4</span> _TextureSampleAdd;

            <span class="pl-k">struct</span> appdata
            {
                <span class="pl-k">float4</span> vertex : <span class="pl-c1">POSITION</span>;
                <span class="pl-k">float4</span> texcoord : <span class="pl-c1">TEXCOORD0</span>;
                <span class="pl-k">float4</span> uv1 : <span class="pl-c1">TEXCOORD1</span>;
                <span class="pl-k">float4</span> uv2 : <span class="pl-c1">TEXCOORD2</span>;
                <span class="pl-k">half4</span> color : <span class="pl-c1">COLOR</span>;
            };


            <span class="pl-k">struct</span> v2f
            {
                <span class="pl-k">float4</span> vertex : <span class="pl-c1">SV_POSITION</span>;
                <span class="pl-k">float4</span> texcoord : <span class="pl-c1">TEXCOORD0</span>;
                <span class="pl-k">float4</span> uv1 : <span class="pl-c1">TEXCOORD1</span>;
                <span class="pl-k">float4</span> uv2 : <span class="pl-c1">TEXCOORD2</span>;
                <span class="pl-k">half4</span> color : <span class="pl-c1">COLOR</span>;

                <span class="pl-k">half4</span> objPosition : <span class="pl-c1">TEXCOORD3</span>;
            };

            v2f <span class="pl-c1">vert</span>(appdata IN)
            {
                v2f o;
  
                o.vertex = <span class="pl-c1">TransformObjectToHClip</span>(IN.vertex.xyz);
                o.texcoord = IN.texcoord;
                o.color = IN.color * _Color;
                o.uv1 = IN.uv1;
                o.uv2 = IN.uv2;

                o.objPosition = IN.vertex;
                <span class="pl-k">return</span> o;
            }

            <span class="pl-k">half</span> <span class="pl-c1">IsInRect</span>(<span class="pl-k">float2</span> pPos, <span class="pl-k">float2</span> pClipRectMin, <span class="pl-k">float2</span> pClipRectMax)
            {
                pPos = <span class="pl-c1">step</span>(pClipRectMin, pPos) * <span class="pl-c1">step</span>(pPos, pClipRectMax);
                <span class="pl-k">return</span> pPos.x * pPos.y;
            }

            <span class="pl-k">half</span> <span class="pl-c1">SampleAlpha</span>(<span class="pl-k">int</span> pIndex, v2f IN)
            {
                <span class="pl-k">const</span> <span class="pl-k">half</span> sinArray[<span class="pl-c1">12</span>] =
                {
                    <span class="pl-c1">0</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">0.866</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0.866</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">0.5</span>, -<span class="pl-c1">0.866</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">0.866</span>, -<span class="pl-c1">0.5</span>
                };
                <span class="pl-k">const</span> <span class="pl-k">half</span> cosArray[<span class="pl-c1">12</span>] =
                {
                    <span class="pl-c1">1</span>, <span class="pl-c1">0.866</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">0</span>, -<span class="pl-c1">0.5</span>, -<span class="pl-c1">0.866</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">0.866</span>, -<span class="pl-c1">0.5</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0.5</span>, <span class="pl-c1">0.866</span>
                };
                <span class="pl-k">float2</span> pos = IN.texcoord.xy + _MainTex_TexelSize.xy * <span class="pl-k">float2</span>(cosArray[pIndex], sinArray[pIndex]) * IN.texcoord.z;
                <span class="pl-k">half</span> pos_uv_col_a = (<span class="pl-c1">SAMPLE_TEXTURE2D</span>(_MainTex, sampler_MainTex, pos) + _TextureSampleAdd).w;
                <span class="pl-k">return</span> <span class="pl-c1">IsInRect</span>(pos, IN.uv1.xy, IN.uv1.zw) * pos_uv_col_a * IN.uv2.w;
            }
  
            <span class="pl-k">half4</span> <span class="pl-c1">frag</span>(v2f IN) : <span class="pl-c1">SV_Target</span>
            {
                <span class="pl-k">half4</span> color = (<span class="pl-c1">SAMPLE_TEXTURE2D</span>(_MainTex, sampler_MainTex, IN.texcoord.xy) + _TextureSampleAdd) * IN.color;

  
                <span class="pl-k">if</span> (<span class="pl-c1">all</span>(IN.texcoord.z))
                {
                    <span class="pl-k">half</span> sign_a = <span class="pl-c1">IsInRect</span>(IN.texcoord.xy, IN.uv1.xy, IN.uv1.zw);
                    color.a *= sign_a;
                    <span class="pl-k">half4</span> val = <span class="pl-k">half4</span>(IN.uv2.rgb, <span class="pl-c1">0</span>);

                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">0</span>, IN);
                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">1</span>, IN);
                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">2</span>, IN);
                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">3</span>, IN);
                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">4</span>, IN);
                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">5</span>, IN);
                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">6</span>, IN);
                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">7</span>, IN);
                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">8</span>, IN);
                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">9</span>, IN);
                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">10</span>, IN);
                    val.w += <span class="pl-c1">SampleAlpha</span>(<span class="pl-c1">11</span>, IN);
                    val.w = <span class="pl-c1">saturate</span>(val.w);

                    val.w *= IN.texcoord.w;
                    color = <span class="pl-c1">lerp</span>(val, color, color.a) * val.w + color * (<span class="pl-c1">1</span> - val.w);
                }


               <span class="pl-c">// 2. --- 核心：应用自定义的RectMask2D裁剪（带软边缘）---</span>
<span class="pl-k">                #if</span> UNITY_UI_CLIP_RECT
                <span class="pl-c">// 2.1 计算片元到裁剪矩形四条边的距离</span>
                <span class="pl-k">half2</span> minDist = (IN.objPosition.xy - _ClipRect.xy);
                <span class="pl-k">half2</span> maxDist = (_ClipRect.zw - IN.objPosition.xy);
                <span class="pl-k">half2</span> edgeDistance = <span class="pl-c1">min</span>(minDist, maxDist); <span class="pl-c">// 对于矩形内的点，这个值是正的</span>

                <span class="pl-c">// 2.2 计算软边缘因子</span>
                <span class="pl-c">// saturate(x / softness) ：</span>
                <span class="pl-c">// - 当 x &gt; softness：结果 &gt;= 1，完全保留</span>
                <span class="pl-c">// - 当 0 &lt; x &lt; softness：结果在 0 到 1 之间，平滑过渡</span>
                <span class="pl-c">// - 当 x &lt; 0：结果为 0，完全裁剪</span>
                <span class="pl-c">// 使用max(softness, 0.001)避免除以零</span>
                <span class="pl-k">half2</span> softnessFactor = <span class="pl-c1">saturate</span>(edgeDistance / <span class="pl-c1">max</span>(_Softness.xy, <span class="pl-c1">0.001</span>));

                <span class="pl-c">// 2.3 综合两个方向的因子（取最小值，这样任何一个方向出界都会导致裁剪）</span>
                <span class="pl-k">half</span> finalAlphaFactor = softnessFactor.x * softnessFactor.y;

                <span class="pl-c">// 2.4 将裁剪因子应用到最终颜色的Alpha通道</span>
                color.a *= finalAlphaFactor;
<span class="pl-k">                #endif</span>

  
<span class="pl-k">                #if</span> UNITY_UI_ALPHACLIP
                    <span class="pl-c1">clip</span>(color.a - _AlphaClipThreshold);
<span class="pl-k">                #endif</span>


                <span class="pl-k">return</span> color;
            }

  
            ENDHLSL
        }
    }
}</pre></div>
</details>
<details>
	<summary>UIOutlineEx</summary>
<div class="highlight highlight-source-cs"><pre class="notranslate"><span class="pl-k">using</span> <span class="pl-s1">UnityEngine</span><span class="pl-kos">;</span>
<span class="pl-k">using</span> <span class="pl-s1">UnityEngine</span><span class="pl-kos">.</span><span class="pl-s1">UI</span><span class="pl-kos">;</span>
<span class="pl-k">using</span> <span class="pl-s1">System</span><span class="pl-kos">.</span><span class="pl-s1">Collections</span><span class="pl-kos">.</span><span class="pl-s1">Generic</span><span class="pl-kos">;</span>

<span class="pl-c">/// &lt;summary&gt;</span>
<span class="pl-c">/// UGUI描边</span>
<span class="pl-c">/// &lt;/summary&gt;</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">UIOutlineEx</span> <span class="pl-c1">:</span> <span class="pl-smi">BaseMeshEffect</span>
<span class="pl-kos">{</span>
    <span class="pl-k">private</span> <span class="pl-k"><span class="pl-k">static</span></span> <span class="pl-smi">List</span><span class="pl-c1">&lt;</span><span class="pl-smi">UIVertex</span><span class="pl-c1">&gt;</span> <span class="pl-s1">m_VetexList</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">List</span><span class="pl-c1">&lt;</span><span class="pl-smi">UIVertex</span><span class="pl-c1">&gt;</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

    <span class="pl-c">// 公开变量</span>
    <span class="pl-k">public</span> <span class="pl-smi">Color</span> <span class="pl-s1">OutlineColor</span> <span class="pl-c1">=</span> <span class="pl-s1">Color</span><span class="pl-kos">.</span><span class="pl-s1">black</span><span class="pl-kos">;</span>
    <span class="pl-kos">[</span><span class="pl-c1">Range</span><span class="pl-kos">(</span><span class="pl-c1">0.01f</span><span class="pl-kos">,</span> <span class="pl-c1">6</span><span class="pl-kos">)</span><span class="pl-kos">]</span> <span class="pl-k">public</span> <span class="pl-smi">float</span> <span class="pl-s1">OutlineWidth</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>
    <span class="pl-kos">[</span><span class="pl-c1">SerializeField</span><span class="pl-kos">]</span> <span class="pl-k">private</span> <span class="pl-smi">Material</span> <span class="pl-s1">m_outlineMaterial</span><span class="pl-kos">;</span>
    <span class="pl-kos">[</span><span class="pl-c1">SerializeField</span><span class="pl-kos">]</span> <span class="pl-k">private</span> <span class="pl-smi">bool</span> <span class="pl-s1">m_DrawOutline</span><span class="pl-kos">;</span>

    <span class="pl-c">// 私有变量</span>
    <span class="pl-k">private</span> <span class="pl-smi">float</span> <span class="pl-s1">m_uivertex_alpha_max</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span><span class="pl-kos">;</span>
    <span class="pl-k">private</span> <span class="pl-smi">CanvasGroup</span><span class="pl-kos">[</span><span class="pl-kos">]</span> <span class="pl-s1">m_canvasGroups</span><span class="pl-kos">;</span>
    <span class="pl-k">private</span> <span class="pl-smi">float</span> <span class="pl-s1">m_canvasGroups_alphamul</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>


    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">SetDrawOutline</span><span class="pl-kos">(</span><span class="pl-smi">bool</span> <span class="pl-s1">draw</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-s1">m_DrawOutline</span> <span class="pl-c1">=</span> <span class="pl-s1">draw</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>
  
  
  
    <span class="pl-k">protected</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">Awake</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-en">Awake</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

        <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-s1">graphic</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-s1">graphic</span><span class="pl-kos">.</span><span class="pl-s1">canvas</span><span class="pl-kos">)</span>
            <span class="pl-kos">{</span>
                <span class="pl-k">var</span> <span class="pl-s1">v1</span> <span class="pl-c1">=</span> <span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-s1">graphic</span><span class="pl-kos">.</span><span class="pl-s1">canvas</span><span class="pl-kos">.</span><span class="pl-s1">additionalShaderChannels</span><span class="pl-kos">;</span>
                <span class="pl-k">var</span> <span class="pl-s1">v2</span> <span class="pl-c1">=</span> <span class="pl-s1">AdditionalCanvasShaderChannels</span><span class="pl-kos">.</span><span class="pl-s1">TexCoord1</span><span class="pl-kos">;</span>
                <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-s1">v1</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">v2</span><span class="pl-kos">)</span> <span class="pl-c1">!=</span> <span class="pl-s1">v2</span><span class="pl-kos">)</span>
                <span class="pl-kos">{</span>
                    <span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-s1">graphic</span><span class="pl-kos">.</span><span class="pl-s1">canvas</span><span class="pl-kos">.</span><span class="pl-s1">additionalShaderChannels</span> <span class="pl-c1">|=</span> <span class="pl-s1">v2</span><span class="pl-kos">;</span>
                <span class="pl-kos">}</span>
                <span class="pl-s1">v2</span> <span class="pl-c1">=</span> <span class="pl-s1">AdditionalCanvasShaderChannels</span><span class="pl-kos">.</span><span class="pl-s1">TexCoord2</span><span class="pl-kos">;</span>
                <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-s1">v1</span> <span class="pl-c1">&amp;</span> <span class="pl-s1">v2</span><span class="pl-kos">)</span> <span class="pl-c1">!=</span> <span class="pl-s1">v2</span><span class="pl-kos">)</span>
                <span class="pl-kos">{</span>
                    <span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-s1">graphic</span><span class="pl-kos">.</span><span class="pl-s1">canvas</span><span class="pl-kos">.</span><span class="pl-s1">additionalShaderChannels</span> <span class="pl-c1">|=</span> <span class="pl-s1">v2</span><span class="pl-kos">;</span>
                <span class="pl-kos">}</span>
            <span class="pl-kos">}</span>
            <span class="pl-k">this</span><span class="pl-kos">.</span><span class="pl-en">_Refresh</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>
    <span class="pl-kos">}</span>

    <span class="pl-k">protected</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">OnDestroy</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-s1">graphic</span><span class="pl-kos">.</span><span class="pl-s1">material</span> <span class="pl-c1">=</span> <span class="pl-c1">null</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>


    <span class="pl-k">protected</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">OnEnable</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-s1">graphic</span><span class="pl-kos">.</span><span class="pl-s1">material</span> <span class="pl-c1">=</span> <span class="pl-s1">m_outlineMaterial</span><span class="pl-kos">;</span>
        <span class="pl-k">this</span><span class="pl-kos">.</span><span class="pl-en">_Refresh</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>

    <span class="pl-k">protected</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">OnDisable</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-s1">graphic</span><span class="pl-kos">.</span><span class="pl-s1">material</span> <span class="pl-c1">=</span> <span class="pl-c1">null</span><span class="pl-kos">;</span>
        <span class="pl-k">this</span><span class="pl-kos">.</span><span class="pl-en">_Refresh</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>

    <span class="pl-k">protected</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">Start</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-s1">graphic</span><span class="pl-kos">.</span><span class="pl-s1">material</span> <span class="pl-c1">=</span> <span class="pl-s1">m_outlineMaterial</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>


    <span class="pl-k">protected</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">OnCanvasGroupChanged</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-en">OnCanvasGroupChanged</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">m_canvasGroups</span> <span class="pl-c1">==</span> <span class="pl-c1">null</span><span class="pl-kos">)</span> <span class="pl-s1">m_canvasGroups</span> <span class="pl-c1">=</span> <span class="pl-smi">GetComponentsInParent</span><span class="pl-c1">&lt;</span><span class="pl-smi">CanvasGroup</span><span class="pl-c1">&gt;</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

        <span class="pl-s1">m_canvasGroups_alphamul</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>
        <span class="pl-k">for</span> <span class="pl-kos">(</span><span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span><span class="pl-kos">;</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">m_canvasGroups</span><span class="pl-kos">.</span><span class="pl-s1">Length</span><span class="pl-kos">;</span> <span class="pl-s1">i</span><span class="pl-c1">++</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-s1">m_canvasGroups_alphamul</span> <span class="pl-c1">*=</span> <span class="pl-s1">m_canvasGroups</span><span class="pl-kos">[</span><span class="pl-s1">i</span><span class="pl-kos">]</span><span class="pl-kos">.</span><span class="pl-s1">alpha</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>
        <span class="pl-k">this</span><span class="pl-kos">.</span><span class="pl-en">_Refresh</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>
  

    <span class="pl-k">private</span> <span class="pl-smi">void</span> <span class="pl-en">_Refresh</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">base</span><span class="pl-kos">.</span><span class="pl-s1">graphic</span><span class="pl-kos">.</span><span class="pl-en">SetVerticesDirty</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>


    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">ModifyMesh</span><span class="pl-kos">(</span><span class="pl-smi">VertexHelper</span> <span class="pl-s1">vh</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">if</span><span class="pl-kos">(</span><span class="pl-c1">!</span><span class="pl-s1">m_DrawOutline</span><span class="pl-kos">)</span> <span class="pl-k">return</span><span class="pl-kos">;</span>
  
        <span class="pl-s1">vh</span><span class="pl-kos">.</span><span class="pl-en">GetUIVertexStream</span><span class="pl-kos">(</span><span class="pl-s1">m_VetexList</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

        <span class="pl-s1">m_uivertex_alpha_max</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span><span class="pl-kos">;</span>
        <span class="pl-k">for</span> <span class="pl-kos">(</span><span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span><span class="pl-kos">;</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">m_VetexList</span><span class="pl-kos">.</span><span class="pl-s1">Count</span><span class="pl-kos">;</span> <span class="pl-s1">i</span><span class="pl-c1">++</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-k">var</span> <span class="pl-s1">v</span> <span class="pl-c1">=</span> <span class="pl-s1">m_VetexList</span><span class="pl-kos">[</span><span class="pl-s1">i</span><span class="pl-kos">]</span><span class="pl-kos">;</span>
            <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">v</span><span class="pl-kos">.</span><span class="pl-s1">color</span><span class="pl-kos">.</span><span class="pl-s1">a</span> <span class="pl-c1">/</span> <span class="pl-c1">255f</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">m_uivertex_alpha_max</span><span class="pl-kos">)</span> <span class="pl-s1">m_uivertex_alpha_max</span> <span class="pl-c1">=</span> <span class="pl-s1">v</span><span class="pl-kos">.</span><span class="pl-s1">color</span><span class="pl-kos">.</span><span class="pl-s1">a</span> <span class="pl-c1">/</span> <span class="pl-c1">255f</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>
        <span class="pl-s1">m_uivertex_alpha_max</span> <span class="pl-c1">*=</span> <span class="pl-s1">m_canvasGroups_alphamul</span><span class="pl-kos">;</span>

        <span class="pl-k">this</span><span class="pl-kos">.</span><span class="pl-en">_ProcessVertices</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

        <span class="pl-s1">vh</span><span class="pl-kos">.</span><span class="pl-en">Clear</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-s1">vh</span><span class="pl-kos">.</span><span class="pl-en">AddUIVertexTriangleStream</span><span class="pl-kos">(</span><span class="pl-s1">m_VetexList</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>


    <span class="pl-k">private</span> <span class="pl-smi">void</span> <span class="pl-en">_ProcessVertices</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">for</span> <span class="pl-kos">(</span><span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-s1">count</span> <span class="pl-c1">=</span> <span class="pl-s1">m_VetexList</span><span class="pl-kos">.</span><span class="pl-s1">Count</span> <span class="pl-c1">-</span> <span class="pl-c1">3</span><span class="pl-kos">;</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">count</span><span class="pl-kos">;</span> <span class="pl-s1">i</span> <span class="pl-c1">+=</span> <span class="pl-c1">3</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-k">var</span> <span class="pl-s1">v1</span> <span class="pl-c1">=</span> <span class="pl-s1">m_VetexList</span><span class="pl-kos">[</span><span class="pl-s1">i</span><span class="pl-kos">]</span><span class="pl-kos">;</span>
            <span class="pl-k">var</span> <span class="pl-s1">v2</span> <span class="pl-c1">=</span> <span class="pl-s1">m_VetexList</span><span class="pl-kos">[</span><span class="pl-s1">i</span> <span class="pl-c1">+</span> <span class="pl-c1">1</span><span class="pl-kos">]</span><span class="pl-kos">;</span>
            <span class="pl-k">var</span> <span class="pl-s1">v3</span> <span class="pl-c1">=</span> <span class="pl-s1">m_VetexList</span><span class="pl-kos">[</span><span class="pl-s1">i</span> <span class="pl-c1">+</span> <span class="pl-c1">2</span><span class="pl-kos">]</span><span class="pl-kos">;</span>
  
  
  
            <span class="pl-c">// 计算原顶点坐标中心点</span>
            <span class="pl-c">//</span>
            <span class="pl-k">var</span> <span class="pl-s1">minX</span> <span class="pl-c1">=</span> <span class="pl-s1">_Min</span><span class="pl-kos">(</span><span class="pl-s1">v1</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">,</span> <span class="pl-s1">v2</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">,</span> <span class="pl-s1">v3</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-k">var</span> <span class="pl-s1">minY</span> <span class="pl-c1">=</span> <span class="pl-s1">_Min</span><span class="pl-kos">(</span><span class="pl-s1">v1</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">,</span> <span class="pl-s1">v2</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">,</span> <span class="pl-s1">v3</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-k">var</span> <span class="pl-s1">maxX</span> <span class="pl-c1">=</span> <span class="pl-s1">_Max</span><span class="pl-kos">(</span><span class="pl-s1">v1</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">,</span> <span class="pl-s1">v2</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">,</span> <span class="pl-s1">v3</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-k">var</span> <span class="pl-s1">maxY</span> <span class="pl-c1">=</span> <span class="pl-s1">_Max</span><span class="pl-kos">(</span><span class="pl-s1">v1</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">,</span> <span class="pl-s1">v2</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">,</span> <span class="pl-s1">v3</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-k">var</span> <span class="pl-s1">posCenter</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">Vector2</span><span class="pl-kos">(</span><span class="pl-s1">minX</span> <span class="pl-c1">+</span> <span class="pl-s1">maxX</span><span class="pl-kos">,</span> <span class="pl-s1">minY</span> <span class="pl-c1">+</span> <span class="pl-s1">maxY</span><span class="pl-kos">)</span> <span class="pl-c1">*</span> <span class="pl-c1">0.5f</span><span class="pl-kos">;</span>
  
  
  
            <span class="pl-c">// 计算原始顶点坐标和UV的方向</span>
            <span class="pl-c">//</span>
            <span class="pl-smi">Vector2</span> <span class="pl-s1">triX</span><span class="pl-kos">,</span> <span class="pl-s1">triY</span><span class="pl-kos">,</span> <span class="pl-s1">uvX</span><span class="pl-kos">,</span> <span class="pl-s1">uvY</span><span class="pl-kos">;</span>
            <span class="pl-smi">Vector2</span> <span class="pl-s1">pos1</span> <span class="pl-c1">=</span> <span class="pl-s1">v1</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">;</span>
            <span class="pl-smi">Vector2</span> <span class="pl-s1">pos2</span> <span class="pl-c1">=</span> <span class="pl-s1">v2</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">;</span>
            <span class="pl-smi">Vector2</span> <span class="pl-s1">pos3</span> <span class="pl-c1">=</span> <span class="pl-s1">v3</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">;</span>
            <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">Mathf</span><span class="pl-kos">.</span><span class="pl-en">Abs</span><span class="pl-kos">(</span><span class="pl-s1">Vector2</span><span class="pl-kos">.</span><span class="pl-en">Dot</span><span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-s1">pos2</span> <span class="pl-c1">-</span> <span class="pl-s1">pos1</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-s1">normalized</span><span class="pl-kos">,</span> <span class="pl-s1">Vector2</span><span class="pl-kos">.</span><span class="pl-s1">right</span><span class="pl-kos">)</span><span class="pl-kos">)</span>
                <span class="pl-c1">&gt;</span> <span class="pl-s1">Mathf</span><span class="pl-kos">.</span><span class="pl-en">Abs</span><span class="pl-kos">(</span><span class="pl-s1">Vector2</span><span class="pl-kos">.</span><span class="pl-en">Dot</span><span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-s1">pos3</span> <span class="pl-c1">-</span> <span class="pl-s1">pos2</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-s1">normalized</span><span class="pl-kos">,</span> <span class="pl-s1">Vector2</span><span class="pl-kos">.</span><span class="pl-s1">right</span><span class="pl-kos">)</span><span class="pl-kos">)</span><span class="pl-kos">)</span>
            <span class="pl-kos">{</span>
                <span class="pl-s1">triX</span> <span class="pl-c1">=</span> <span class="pl-s1">pos2</span> <span class="pl-c1">-</span> <span class="pl-s1">pos1</span><span class="pl-kos">;</span>
                <span class="pl-s1">triY</span> <span class="pl-c1">=</span> <span class="pl-s1">pos3</span> <span class="pl-c1">-</span> <span class="pl-s1">pos2</span><span class="pl-kos">;</span>
                <span class="pl-s1">uvX</span> <span class="pl-c1">=</span> <span class="pl-s1">v2</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span> <span class="pl-c1">-</span> <span class="pl-s1">v1</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">;</span>
                <span class="pl-s1">uvY</span> <span class="pl-c1">=</span> <span class="pl-s1">v3</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span> <span class="pl-c1">-</span> <span class="pl-s1">v2</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">;</span>
            <span class="pl-kos">}</span>
            <span class="pl-k">else</span>
            <span class="pl-kos">{</span>
                <span class="pl-s1">triX</span> <span class="pl-c1">=</span> <span class="pl-s1">pos3</span> <span class="pl-c1">-</span> <span class="pl-s1">pos2</span><span class="pl-kos">;</span>
                <span class="pl-s1">triY</span> <span class="pl-c1">=</span> <span class="pl-s1">pos2</span> <span class="pl-c1">-</span> <span class="pl-s1">pos1</span><span class="pl-kos">;</span>
                <span class="pl-s1">uvX</span> <span class="pl-c1">=</span> <span class="pl-s1">v3</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span> <span class="pl-c1">-</span> <span class="pl-s1">v2</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">;</span>
                <span class="pl-s1">uvY</span> <span class="pl-c1">=</span> <span class="pl-s1">v2</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span> <span class="pl-c1">-</span> <span class="pl-s1">v1</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">;</span>
            <span class="pl-kos">}</span>
  
  
  
            <span class="pl-c">// 计算原始UV框</span>
            <span class="pl-k">var</span> <span class="pl-s1">uvMin</span> <span class="pl-c1">=</span> <span class="pl-s1">_Min</span><span class="pl-kos">(</span><span class="pl-s1">v1</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">,</span> <span class="pl-s1">v2</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">,</span> <span class="pl-s1">v3</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-k">var</span> <span class="pl-s1">uvMax</span> <span class="pl-c1">=</span> <span class="pl-s1">_Max</span><span class="pl-kos">(</span><span class="pl-s1">v1</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">,</span> <span class="pl-s1">v2</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">,</span> <span class="pl-s1">v3</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

            <span class="pl-c">// 为每个顶点设置新的Position和UV，并传入原始UV框</span>
            <span class="pl-s1">v1</span> <span class="pl-c1">=</span> <span class="pl-s1">_SetNewPosAndUV</span><span class="pl-kos">(</span><span class="pl-s1">v1</span><span class="pl-kos">,</span> <span class="pl-k">this</span><span class="pl-kos">.</span><span class="pl-s1">OutlineWidth</span><span class="pl-kos">,</span> <span class="pl-s1">posCenter</span><span class="pl-kos">,</span> <span class="pl-s1">triX</span><span class="pl-kos">,</span> <span class="pl-s1">triY</span><span class="pl-kos">,</span> <span class="pl-s1">uvX</span><span class="pl-kos">,</span> <span class="pl-s1">uvY</span><span class="pl-kos">,</span> <span class="pl-s1">uvMin</span><span class="pl-kos">,</span> <span class="pl-s1">uvMax</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">v2</span> <span class="pl-c1">=</span> <span class="pl-s1">_SetNewPosAndUV</span><span class="pl-kos">(</span><span class="pl-s1">v2</span><span class="pl-kos">,</span> <span class="pl-k">this</span><span class="pl-kos">.</span><span class="pl-s1">OutlineWidth</span><span class="pl-kos">,</span> <span class="pl-s1">posCenter</span><span class="pl-kos">,</span> <span class="pl-s1">triX</span><span class="pl-kos">,</span> <span class="pl-s1">triY</span><span class="pl-kos">,</span> <span class="pl-s1">uvX</span><span class="pl-kos">,</span> <span class="pl-s1">uvY</span><span class="pl-kos">,</span> <span class="pl-s1">uvMin</span><span class="pl-kos">,</span> <span class="pl-s1">uvMax</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">v3</span> <span class="pl-c1">=</span> <span class="pl-s1">_SetNewPosAndUV</span><span class="pl-kos">(</span><span class="pl-s1">v3</span><span class="pl-kos">,</span> <span class="pl-k">this</span><span class="pl-kos">.</span><span class="pl-s1">OutlineWidth</span><span class="pl-kos">,</span> <span class="pl-s1">posCenter</span><span class="pl-kos">,</span> <span class="pl-s1">triX</span><span class="pl-kos">,</span> <span class="pl-s1">triY</span><span class="pl-kos">,</span> <span class="pl-s1">uvX</span><span class="pl-kos">,</span> <span class="pl-s1">uvY</span><span class="pl-kos">,</span> <span class="pl-s1">uvMin</span><span class="pl-kos">,</span> <span class="pl-s1">uvMax</span><span class="pl-kos">)</span><span class="pl-kos">;</span>


            <span class="pl-c">// 应用设置后的UIVertex</span>
            <span class="pl-c">//</span>
            <span class="pl-s1">m_VetexList</span><span class="pl-kos">[</span><span class="pl-s1">i</span><span class="pl-kos">]</span> <span class="pl-c1">=</span> <span class="pl-s1">v1</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_VetexList</span><span class="pl-kos">[</span><span class="pl-s1">i</span> <span class="pl-c1">+</span> <span class="pl-c1">1</span><span class="pl-kos">]</span> <span class="pl-c1">=</span> <span class="pl-s1">v2</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_VetexList</span><span class="pl-kos">[</span><span class="pl-s1">i</span> <span class="pl-c1">+</span> <span class="pl-c1">2</span><span class="pl-kos">]</span> <span class="pl-c1">=</span> <span class="pl-s1">v3</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>
    <span class="pl-kos">}</span>


    <span class="pl-k">private</span> <span class="pl-s1">UIVertex</span> <span class="pl-en">_SetNewPosAndUV</span><span class="pl-kos">(</span>
        <span class="pl-smi">UIVertex</span> <span class="pl-s1">pVertex</span><span class="pl-kos">,</span> <span class="pl-smi">float</span> <span class="pl-s1">pOutLineWidth</span><span class="pl-kos">,</span>
        <span class="pl-smi">Vector2</span> <span class="pl-s1">pPosCenter</span><span class="pl-kos">,</span>
        <span class="pl-smi">Vector2</span> <span class="pl-s1">pTriangleX</span><span class="pl-kos">,</span> <span class="pl-smi">Vector2</span> <span class="pl-s1">pTriangleY</span><span class="pl-kos">,</span>
        <span class="pl-smi">Vector2</span> <span class="pl-s1">pUVX</span><span class="pl-kos">,</span> <span class="pl-smi">Vector2</span> <span class="pl-s1">pUVY</span><span class="pl-kos">,</span>
        <span class="pl-smi">Vector2</span> <span class="pl-s1">pUVOriginMin</span><span class="pl-kos">,</span> <span class="pl-smi">Vector2</span> <span class="pl-s1">pUVOriginMax</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-c">// Position</span>
        <span class="pl-k">var</span> <span class="pl-s1">pos</span> <span class="pl-c1">=</span> <span class="pl-s1">pVertex</span><span class="pl-kos">.</span><span class="pl-s1">position</span><span class="pl-kos">;</span>
        <span class="pl-k">var</span> <span class="pl-s1">posXOffset</span> <span class="pl-c1">=</span> <span class="pl-s1">pos</span><span class="pl-kos">.</span><span class="pl-s1">x</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">pPosCenter</span><span class="pl-kos">.</span><span class="pl-s1">x</span> <span class="pl-c1">?</span> <span class="pl-s1">pOutLineWidth</span> <span class="pl-c1">:</span> <span class="pl-c1">-</span><span class="pl-s1">pOutLineWidth</span><span class="pl-kos">;</span>
        <span class="pl-k">var</span> <span class="pl-s1">posYOffset</span> <span class="pl-c1">=</span> <span class="pl-s1">pos</span><span class="pl-kos">.</span><span class="pl-s1">y</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">pPosCenter</span><span class="pl-kos">.</span><span class="pl-s1">y</span> <span class="pl-c1">?</span> <span class="pl-s1">pOutLineWidth</span> <span class="pl-c1">:</span> <span class="pl-c1">-</span><span class="pl-s1">pOutLineWidth</span><span class="pl-kos">;</span>
        <span class="pl-s1">pos</span><span class="pl-kos">.</span><span class="pl-s1">x</span> <span class="pl-c1">+=</span> <span class="pl-s1">posXOffset</span><span class="pl-kos">;</span>
        <span class="pl-s1">pos</span><span class="pl-kos">.</span><span class="pl-s1">y</span> <span class="pl-c1">+=</span> <span class="pl-s1">posYOffset</span><span class="pl-kos">;</span>
        <span class="pl-s1">pVertex</span><span class="pl-kos">.</span><span class="pl-s1">position</span> <span class="pl-c1">=</span> <span class="pl-s1">pos</span><span class="pl-kos">;</span>
  
        <span class="pl-c">// UV</span>
        <span class="pl-k">var</span> <span class="pl-s1">uv</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span><span class="pl-smi">Vector2</span><span class="pl-kos">)</span><span class="pl-s1">pVertex</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">;</span>
        <span class="pl-k">var</span> <span class="pl-s1">uv_additional_x</span> <span class="pl-c1">=</span> <span class="pl-s1">pUVX</span> <span class="pl-c1">/</span> <span class="pl-s1">pTriangleX</span><span class="pl-kos">.</span><span class="pl-s1">magnitude</span> <span class="pl-c1">*</span> <span class="pl-s1">posXOffset</span> <span class="pl-c1">*</span> <span class="pl-kos">(</span><span class="pl-s1">Vector2</span><span class="pl-kos">.</span><span class="pl-en">Dot</span><span class="pl-kos">(</span><span class="pl-s1">pTriangleX</span><span class="pl-kos">,</span> <span class="pl-s1">Vector2</span><span class="pl-kos">.</span><span class="pl-s1">right</span><span class="pl-kos">)</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span> <span class="pl-c1">?</span> <span class="pl-c1">1</span> <span class="pl-c1">:</span> <span class="pl-c1">-</span><span class="pl-c1">1</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-k">var</span> <span class="pl-s1">uv_additional_y</span> <span class="pl-c1">=</span> <span class="pl-s1">pUVY</span> <span class="pl-c1">/</span> <span class="pl-s1">pTriangleY</span><span class="pl-kos">.</span><span class="pl-s1">magnitude</span> <span class="pl-c1">*</span> <span class="pl-s1">posYOffset</span> <span class="pl-c1">*</span> <span class="pl-kos">(</span><span class="pl-s1">Vector2</span><span class="pl-kos">.</span><span class="pl-en">Dot</span><span class="pl-kos">(</span><span class="pl-s1">pTriangleY</span><span class="pl-kos">,</span> <span class="pl-s1">Vector2</span><span class="pl-kos">.</span><span class="pl-s1">up</span><span class="pl-kos">)</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span> <span class="pl-c1">?</span> <span class="pl-c1">1</span> <span class="pl-c1">:</span> <span class="pl-c1">-</span><span class="pl-c1">1</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-s1">uv</span> <span class="pl-c1">+=</span> <span class="pl-s1">uv_additional_x</span><span class="pl-kos">;</span>
        <span class="pl-s1">uv</span> <span class="pl-c1">+=</span> <span class="pl-s1">uv_additional_y</span><span class="pl-kos">;</span>
        <span class="pl-s1">pVertex</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span> <span class="pl-c1">=</span> <span class="pl-s1">uv</span><span class="pl-kos">;</span>
  
  
        <span class="pl-s1">pVertex</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">.</span><span class="pl-s1">z</span> <span class="pl-c1">=</span> <span class="pl-s1">pOutLineWidth</span><span class="pl-kos">;</span> <span class="pl-c">// z：定位为宽度</span>
        <span class="pl-s1">pVertex</span><span class="pl-kos">.</span><span class="pl-s1">uv0</span><span class="pl-kos">.</span><span class="pl-s1">w</span> <span class="pl-c1">=</span> <span class="pl-s1">m_uivertex_alpha_max</span><span class="pl-kos">;</span> <span class="pl-c">// w：所有顶点中最大的透明度值</span>

  
        <span class="pl-c">// uv1 uv2 可用</span>
        <span class="pl-s1">pVertex</span><span class="pl-kos">.</span><span class="pl-s1">uv1</span> <span class="pl-c1">=</span> <span class="pl-s1">pUVOriginMin</span><span class="pl-kos">;</span>     <span class="pl-c">// uv1：定位为最小最大值数据</span>
        <span class="pl-s1">pVertex</span><span class="pl-kos">.</span><span class="pl-s1">uv1</span><span class="pl-kos">.</span><span class="pl-s1">z</span> <span class="pl-c1">=</span> <span class="pl-s1">pUVOriginMax</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">;</span>
        <span class="pl-s1">pVertex</span><span class="pl-kos">.</span><span class="pl-s1">uv1</span><span class="pl-kos">.</span><span class="pl-s1">w</span> <span class="pl-c1">=</span> <span class="pl-s1">pUVOriginMax</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">;</span>

        <span class="pl-s1">pVertex</span><span class="pl-kos">.</span><span class="pl-s1">uv2</span> <span class="pl-c1">=</span> <span class="pl-k">this</span><span class="pl-kos">.</span><span class="pl-s1">OutlineColor</span><span class="pl-kos">;</span> <span class="pl-c">// uv2：定位为描边颜色</span>

        <span class="pl-k">return</span> <span class="pl-s1">pVertex</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>


    <span class="pl-k">private</span> <span class="pl-k"><span class="pl-k">static</span></span> <span class="pl-smi">float</span> <span class="pl-en">_Min</span><span class="pl-kos">(</span><span class="pl-smi">float</span> <span class="pl-s1">pA</span><span class="pl-kos">,</span> <span class="pl-smi">float</span> <span class="pl-s1">pB</span><span class="pl-kos">,</span> <span class="pl-smi">float</span> <span class="pl-s1">pC</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">return</span> <span class="pl-s1">Mathf</span><span class="pl-kos">.</span><span class="pl-en">Min</span><span class="pl-kos">(</span><span class="pl-s1">Mathf</span><span class="pl-kos">.</span><span class="pl-en">Min</span><span class="pl-kos">(</span><span class="pl-s1">pA</span><span class="pl-kos">,</span> <span class="pl-s1">pB</span><span class="pl-kos">)</span><span class="pl-kos">,</span> <span class="pl-s1">pC</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>


    <span class="pl-k">private</span> <span class="pl-k"><span class="pl-k">static</span></span> <span class="pl-smi">float</span> <span class="pl-en">_Max</span><span class="pl-kos">(</span><span class="pl-smi">float</span> <span class="pl-s1">pA</span><span class="pl-kos">,</span> <span class="pl-smi">float</span> <span class="pl-s1">pB</span><span class="pl-kos">,</span> <span class="pl-smi">float</span> <span class="pl-s1">pC</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">return</span> <span class="pl-s1">Mathf</span><span class="pl-kos">.</span><span class="pl-en">Max</span><span class="pl-kos">(</span><span class="pl-s1">Mathf</span><span class="pl-kos">.</span><span class="pl-en">Max</span><span class="pl-kos">(</span><span class="pl-s1">pA</span><span class="pl-kos">,</span> <span class="pl-s1">pB</span><span class="pl-kos">)</span><span class="pl-kos">,</span> <span class="pl-s1">pC</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>


    <span class="pl-k">private</span> <span class="pl-k"><span class="pl-k">static</span></span> <span class="pl-s1">Vector2</span> <span class="pl-en">_Min</span><span class="pl-kos">(</span><span class="pl-smi">Vector2</span> <span class="pl-s1">pA</span><span class="pl-kos">,</span> <span class="pl-smi">Vector2</span> <span class="pl-s1">pB</span><span class="pl-kos">,</span> <span class="pl-smi">Vector2</span> <span class="pl-s1">pC</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">Vector2</span><span class="pl-kos">(</span><span class="pl-s1">_Min</span><span class="pl-kos">(</span><span class="pl-s1">pA</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">,</span> <span class="pl-s1">pB</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">,</span> <span class="pl-s1">pC</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">)</span><span class="pl-kos">,</span> <span class="pl-s1">_Min</span><span class="pl-kos">(</span><span class="pl-s1">pA</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">,</span> <span class="pl-s1">pB</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">,</span> <span class="pl-s1">pC</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">)</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>


    <span class="pl-k">private</span> <span class="pl-k"><span class="pl-k">static</span></span> <span class="pl-s1">Vector2</span> <span class="pl-en">_Max</span><span class="pl-kos">(</span><span class="pl-smi">Vector2</span> <span class="pl-s1">pA</span><span class="pl-kos">,</span> <span class="pl-smi">Vector2</span> <span class="pl-s1">pB</span><span class="pl-kos">,</span> <span class="pl-smi">Vector2</span> <span class="pl-s1">pC</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">Vector2</span><span class="pl-kos">(</span><span class="pl-s1">_Max</span><span class="pl-kos">(</span><span class="pl-s1">pA</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">,</span> <span class="pl-s1">pB</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">,</span> <span class="pl-s1">pC</span><span class="pl-kos">.</span><span class="pl-s1">x</span><span class="pl-kos">)</span><span class="pl-kos">,</span> <span class="pl-s1">_Max</span><span class="pl-kos">(</span><span class="pl-s1">pA</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">,</span> <span class="pl-s1">pB</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">,</span> <span class="pl-s1">pC</span><span class="pl-kos">.</span><span class="pl-s1">y</span><span class="pl-kos">)</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span></pre></div>
</details>
<h5>后处理Feature</h5>
<details>
	<summary>URP_Feature_Outline3D</summary>
<div class="highlight highlight-source-cs"><pre class="notranslate"><span class="pl-k">using</span> <span class="pl-s1">System</span><span class="pl-kos">.</span><span class="pl-s1">Collections</span><span class="pl-kos">.</span><span class="pl-s1">Generic</span><span class="pl-kos">;</span>
<span class="pl-k">using</span> <span class="pl-s1">UnityEngine</span><span class="pl-kos">;</span>
<span class="pl-k">using</span> <span class="pl-s1">UnityEngine</span><span class="pl-kos">.</span><span class="pl-s1">Rendering</span><span class="pl-kos">;</span>
<span class="pl-k">using</span> <span class="pl-s1">UnityEngine</span><span class="pl-kos">.</span><span class="pl-s1">Rendering</span><span class="pl-kos">.</span><span class="pl-s1">Universal</span><span class="pl-kos">;</span>

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">URP_Feature_Outline3D</span> <span class="pl-c1">:</span> <span class="pl-smi">ScriptableRendererFeature</span>
<span class="pl-kos">{</span>
    <span class="pl-k">class</span> <span class="pl-smi">Outline3DRenderPass</span> <span class="pl-c1">:</span> <span class="pl-smi">ScriptableRenderPass</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">private</span> <span class="pl-k"><span class="pl-k">static</span></span> <span class="pl-k">readonly</span> <span class="pl-smi">List</span><span class="pl-c1">&lt;</span><span class="pl-smi">ShaderTagId</span><span class="pl-c1">&gt;</span> <span class="pl-s1">s_shaderTagIds</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">List</span><span class="pl-c1">&lt;</span><span class="pl-smi">ShaderTagId</span><span class="pl-c1">&gt;</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-k">new</span> <span class="pl-smi">ShaderTagId</span><span class="pl-kos">(</span><span class="pl-s">"UniversalForward"</span><span class="pl-kos">)</span><span class="pl-kos">,</span>
            <span class="pl-k">new</span> <span class="pl-smi">ShaderTagId</span><span class="pl-kos">(</span><span class="pl-s">"UniversalForwardOnly"</span><span class="pl-kos">)</span><span class="pl-kos">,</span>
            <span class="pl-k">new</span> <span class="pl-smi">ShaderTagId</span><span class="pl-kos">(</span><span class="pl-s">"SRPDefaultUnlit"</span><span class="pl-kos">)</span>
        <span class="pl-kos">}</span><span class="pl-kos">;</span>
        <span class="pl-k">private</span> <span class="pl-k"><span class="pl-k">static</span></span> <span class="pl-k">readonly</span> <span class="pl-smi">int</span> <span class="pl-s1">s_shaderProperty_outline3d</span> <span class="pl-c1">=</span> <span class="pl-s1">Shader</span><span class="pl-kos">.</span><span class="pl-en">PropertyToID</span><span class="pl-kos">(</span><span class="pl-s">"_Outline3D"</span><span class="pl-kos">)</span><span class="pl-kos">;</span>



        <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-smi">Material</span> <span class="pl-s1">m_outline_material</span><span class="pl-kos">;</span>
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-smi">FilteringSettings</span> <span class="pl-s1">m_filteringSettings</span><span class="pl-kos">;</span>
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-smi">MaterialPropertyBlock</span> <span class="pl-s1">m_materialPropertyBlock</span><span class="pl-kos">;</span>
        <span class="pl-k">private</span> <span class="pl-smi">RTHandle</span> <span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">;</span>


        <span class="pl-k">public</span> <span class="pl-v">Outline3DRenderPass</span><span class="pl-kos">(</span><span class="pl-smi">Material</span> <span class="pl-s1">material</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-c">// Configures where the render pass should be injected.</span>
            <span class="pl-s1">renderPassEvent</span> <span class="pl-c1">=</span> <span class="pl-s1">RenderPassEvent</span><span class="pl-kos">.</span><span class="pl-s1">AfterRenderingPostProcessing</span><span class="pl-kos">;</span>
        
            <span class="pl-s1">m_outline_material</span> <span class="pl-c1">=</span> <span class="pl-s1">material</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_filteringSettings</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">FilteringSettings</span><span class="pl-kos">(</span><span class="pl-s1">RenderQueueRange</span><span class="pl-kos">.</span><span class="pl-s1">all</span><span class="pl-kos">,</span> <span class="pl-s1">renderingLayerMask</span><span class="pl-c1">:</span> <span class="pl-c1">0b10</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_materialPropertyBlock</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">MaterialPropertyBlock</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>


        <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">Dispose</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-s1">m_outline_rtHandle</span><span class="pl-c1">?</span><span class="pl-kos">.</span><span class="pl-s1">Release</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_outline_rtHandle</span> <span class="pl-c1">=</span> <span class="pl-c1">null</span><span class="pl-kos">;</span>
        
        <span class="pl-kos">}</span>





        <span class="pl-c">// This method is called before executing the render pass.</span>
        <span class="pl-c">// It can be used to configure render targets and their clear state. Also to create temporary render target textures.</span>
        <span class="pl-c">// When empty this render pass will render to the active camera render target.</span>
        <span class="pl-c">// You should never call CommandBuffer.SetRenderTarget. Instead call &lt;c&gt;ConfigureTarget&lt;/c&gt; and &lt;c&gt;ConfigureClear&lt;/c&gt;.</span>
        <span class="pl-c">// The render pipeline will ensure target setup and clearing happens in a performant manner.</span>
        <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">OnCameraSetup</span><span class="pl-kos">(</span><span class="pl-smi">CommandBuffer</span> <span class="pl-s1">cmd</span><span class="pl-kos">,</span> <span class="pl-k">ref</span> <span class="pl-smi">RenderingData</span> <span class="pl-s1">renderingData</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>

            <span class="pl-k">var</span> <span class="pl-s1">desc_camera</span> <span class="pl-c1">=</span> <span class="pl-s1">renderingData</span><span class="pl-kos">.</span><span class="pl-s1">cameraData</span><span class="pl-kos">.</span><span class="pl-s1">cameraTargetDescriptor</span><span class="pl-kos">;</span>
            <span class="pl-s1">desc_camera</span><span class="pl-kos">.</span><span class="pl-s1">msaaSamples</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>
            <span class="pl-s1">desc_camera</span><span class="pl-kos">.</span><span class="pl-s1">depthBufferBits</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span><span class="pl-kos">;</span>
            <span class="pl-s1">desc_camera</span><span class="pl-kos">.</span><span class="pl-s1">colorFormat</span> <span class="pl-c1">=</span> <span class="pl-s1">RenderTextureFormat</span><span class="pl-kos">.</span><span class="pl-s1">ARGB32</span><span class="pl-kos">;</span>
            <span class="pl-s1">RenderingUtils</span><span class="pl-kos">.</span><span class="pl-en">ReAllocateIfNeeded</span><span class="pl-kos">(</span><span class="pl-k">ref</span> <span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">,</span> <span class="pl-s1">desc_camera</span><span class="pl-kos">,</span> <span class="pl-s1">name</span><span class="pl-c1">:</span> <span class="pl-s">"_Outline3D"</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>

        <span class="pl-c">// Here you can implement the rendering logic.</span>
        <span class="pl-c">// Use &lt;c&gt;ScriptableRenderContext&lt;/c&gt; to issue drawing commands or execute command buffers</span>
        <span class="pl-c">// https://docs.unity3d.com/ScriptReference/Rendering.ScriptableRenderContext.html</span>
        <span class="pl-c">// You don't have to call ScriptableRenderContext.submit, the render pipeline will call it at specific points in the pipeline.</span>
        <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">Execute</span><span class="pl-kos">(</span><span class="pl-smi">ScriptableRenderContext</span> <span class="pl-s1">context</span><span class="pl-kos">,</span> <span class="pl-k">ref</span> <span class="pl-smi">RenderingData</span> <span class="pl-s1">renderingData</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-k">var</span> <span class="pl-s1">cmd</span> <span class="pl-c1">=</span> <span class="pl-s1">CommandBufferPool</span><span class="pl-kos">.</span><span class="pl-en">Get</span><span class="pl-kos">(</span><span class="pl-s">"Outline3D CMD"</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

            <span class="pl-c">// CMD</span>
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">SetRenderTarget</span><span class="pl-kos">(</span><span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">ClearRenderTarget</span><span class="pl-kos">(</span><span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-s1">Color</span><span class="pl-kos">.</span><span class="pl-s1">clear</span><span class="pl-kos">)</span><span class="pl-kos">;</span>


            <span class="pl-k">var</span> <span class="pl-s1">draw_settings</span> <span class="pl-c1">=</span> <span class="pl-s1">CreateDrawingSettings</span><span class="pl-kos">(</span><span class="pl-s1">s_shaderTagIds</span><span class="pl-kos">,</span> <span class="pl-k">ref</span> <span class="pl-s1">renderingData</span><span class="pl-kos">,</span> <span class="pl-s1">SortingCriteria</span><span class="pl-kos">.</span><span class="pl-s1">None</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-smi">RendererListParams</span> <span class="pl-s1">rendererListParams</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">RendererListParams</span><span class="pl-kos">(</span><span class="pl-s1">renderingData</span><span class="pl-kos">.</span><span class="pl-s1">cullResults</span><span class="pl-kos">,</span> <span class="pl-s1">draw_settings</span><span class="pl-kos">,</span> <span class="pl-s1">m_filteringSettings</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-k">var</span> <span class="pl-s1">list_draw</span> <span class="pl-c1">=</span> <span class="pl-s1">context</span><span class="pl-kos">.</span><span class="pl-en">CreateRendererList</span><span class="pl-kos">(</span><span class="pl-k">ref</span> <span class="pl-s1">rendererListParams</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">DrawRendererList</span><span class="pl-kos">(</span><span class="pl-s1">list_draw</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        
        
            <span class="pl-c">// cmd.SetRenderTarget(renderingData.cameraData.renderer.cameraColorTargetHandle);</span>
            <span class="pl-c">// m_materialPropertyBlock.SetTexture(s_shaderProperty_outline3d, m_outline_rtHandle);</span>
            <span class="pl-c">// cmd.DrawProcedural(Matrix4x4.identity, m_outline_material, 0, MeshTopology.Triangles, 3, 1, m_materialPropertyBlock);</span>
            <span class="pl-s1">m_outline_material</span><span class="pl-kos">.</span><span class="pl-en">SetTexture</span><span class="pl-kos">(</span><span class="pl-s1">s_shaderProperty_outline3d</span><span class="pl-kos">,</span> <span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">Blitter</span><span class="pl-kos">.</span><span class="pl-en">BlitCameraTexture</span><span class="pl-kos">(</span><span class="pl-s1">cmd</span><span class="pl-kos">,</span> <span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">,</span><span class="pl-s1">renderingData</span><span class="pl-kos">.</span><span class="pl-s1">cameraData</span><span class="pl-kos">.</span><span class="pl-s1">renderer</span><span class="pl-kos">.</span><span class="pl-s1">cameraColorTargetHandle</span><span class="pl-kos">,</span><span class="pl-s1">m_outline_material</span><span class="pl-kos">,</span><span class="pl-c1">0</span><span class="pl-kos">)</span><span class="pl-kos">;</span>



            <span class="pl-s1">context</span><span class="pl-kos">.</span><span class="pl-en">ExecuteCommandBuffer</span><span class="pl-kos">(</span><span class="pl-s1">cmd</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">Clear</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">CommandBufferPool</span><span class="pl-kos">.</span><span class="pl-en">Release</span><span class="pl-kos">(</span><span class="pl-s1">cmd</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>

        <span class="pl-c">// Cleanup any allocated resources that were created during the execution of this render pass.</span>
        <span class="pl-c">//public override void OnCameraCleanup(CommandBuffer cmd)</span>
        <span class="pl-c">//{</span>
        <span class="pl-c">//}</span>
    <span class="pl-kos">}</span>






    <span class="pl-kos">[</span><span class="pl-c1">SerializeField</span><span class="pl-kos">]</span> <span class="pl-k">private</span> <span class="pl-smi">Material</span> <span class="pl-s1">m_OutlineMaterial</span><span class="pl-kos">;</span>
    <span class="pl-k">private</span> <span class="pl-smi">Outline3DRenderPass</span> <span class="pl-s1">m_Outline3DScriptablePass</span><span class="pl-kos">;</span>

    <span class="pl-k">private</span> <span class="pl-smi">bool</span> <span class="pl-s1">IsMaterialValid</span> <span class="pl-c1">=&gt;</span> <span class="pl-s1">m_OutlineMaterial</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">m_OutlineMaterial</span><span class="pl-kos">.</span><span class="pl-s1">shader</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">m_OutlineMaterial</span><span class="pl-kos">.</span><span class="pl-s1">shader</span><span class="pl-kos">.</span><span class="pl-s1">isSupported</span><span class="pl-kos">;</span>


    <span class="pl-c">/// &lt;inheritdoc/&gt;</span>
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">Create</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-c1">!</span><span class="pl-s1">IsMaterialValid</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-k">return</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>

        <span class="pl-s1">m_Outline3DScriptablePass</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">Outline3DRenderPass</span><span class="pl-kos">(</span><span class="pl-s1">m_OutlineMaterial</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>

    <span class="pl-c">// Here you can inject one or multiple render passes in the renderer.</span>
    <span class="pl-c">// This method is called when setting up the renderer once per-camera.</span>
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">AddRenderPasses</span><span class="pl-kos">(</span><span class="pl-smi">ScriptableRenderer</span> <span class="pl-s1">renderer</span><span class="pl-kos">,</span> <span class="pl-k">ref</span> <span class="pl-smi">RenderingData</span> <span class="pl-s1">renderingData</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">m_Outline3DScriptablePass</span> <span class="pl-c1">==</span> <span class="pl-c1">null</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-k">return</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>


        <span class="pl-s1">renderer</span><span class="pl-kos">.</span><span class="pl-en">EnqueuePass</span><span class="pl-kos">(</span><span class="pl-s1">m_Outline3DScriptablePass</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>


    <span class="pl-k">protected</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">Dispose</span><span class="pl-kos">(</span><span class="pl-smi">bool</span> <span class="pl-s1">disposing</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-s1">m_Outline3DScriptablePass</span><span class="pl-c1">?</span><span class="pl-kos">.</span><span class="pl-s1">Dispose</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>

<span class="pl-kos">}</span></pre></div>
</details>
<details>
	<summary>Outline3D</summary>
<div class="highlight highlight-source-hlsl"><pre class="notranslate">Shader <span class="pl-s">"URP/Outline3D"</span>
{
    Properties
    {
        <span class="pl-c1">_OutlineColor</span> (<span class="pl-s">"Outline Color"</span>, Color) = (<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)
        <span class="pl-c1">_OutlineWidth</span> (<span class="pl-s">"Outline Width"</span>, <span class="pl-c1">Range</span>(<span class="pl-c1">0</span>, <span class="pl-c1">0.01</span>)) = <span class="pl-c1">0.001</span>
    }

    SubShader
    {
        Tags
        {
            <span class="pl-s">"RenderType"</span> = <span class="pl-s">"Opaque"</span>
            <span class="pl-s">"RenderPipeline"</span> = <span class="pl-s">"UniversalPipeline"</span>
            <span class="pl-s">"Queue"</span> = <span class="pl-s">"Geometry"</span>
        }
        LOD <span class="pl-c1">100</span>
        
        ZWrite Off
        Cull Off
        Blend SrcAlpha OneMinusSrcAlpha

        Pass
        {
            HLSLPROGRAM

<span class="pl-k">            #pragma</span> vertex vert
<span class="pl-k">            #pragma</span> fragment frag

            
<span class="pl-k">            #include</span> <span class="pl-s">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"</span>
<span class="pl-k">            #include</span> <span class="pl-s">"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"</span>


            <span class="pl-k">struct</span> Attributes
            {
                <span class="pl-k">uint</span> vertex_id : <span class="pl-c1">SV_VERTEXID</span>;
            };

            <span class="pl-k">struct</span> Varyings
            {
                <span class="pl-k">float4</span> positionCS : <span class="pl-c1">SV_POSITION</span>;
                <span class="pl-k">half2</span> uv : <span class="pl-c1">TEXCOORD</span>;
                <span class="pl-k">half2</span> offsets[<span class="pl-c1">8</span>] : <span class="pl-c1">TEXCOORD1</span>;
            };


            <span class="pl-c1">TEXTURE2D_X</span>(_Outline3D);
            <span class="pl-c1">SAMPLER</span>(sampler_linear_clamp_Outline3D);

            <span class="pl-c1">CBUFFER_START</span>(UnityPerMaterial)
            <span class="pl-k">half4</span> _OutlineColor;
            <span class="pl-k">float</span> _OutlineWidth;
            CBUFFER_END


            Varyings <span class="pl-c1">vert</span>(Attributes IN)
            {
                Varyings Output;
                Output.positionCS = <span class="pl-c1">GetFullScreenTriangleVertexPosition</span>(IN.vertex_id);
                Output.uv = <span class="pl-c1">GetFullScreenTriangleTexCoord</span>(IN.vertex_id);

                <span class="pl-k">const</span> <span class="pl-k">half</span> ratio_w_h = _ScreenParams.x / _ScreenParams.y;
                <span class="pl-k">const</span> <span class="pl-k">float</span> multipty_num_2 = <span class="pl-c1">0.707</span>; <span class="pl-c">// sprt(2) / 2</span>

                Output.offsets[<span class="pl-c1">0</span>] = <span class="pl-k">half2</span>(-<span class="pl-c1">1</span>, ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[<span class="pl-c1">1</span>] = <span class="pl-k">half2</span>(<span class="pl-c1">0</span>, ratio_w_h) * _OutlineWidth;
                Output.offsets[<span class="pl-c1">2</span>] = <span class="pl-k">half2</span>(<span class="pl-c1">1</span>, ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[<span class="pl-c1">3</span>] = <span class="pl-k">half2</span>(-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>) * _OutlineWidth;
                
                Output.offsets[<span class="pl-c1">4</span>] = <span class="pl-k">half2</span>(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>) * _OutlineWidth;
                Output.offsets[<span class="pl-c1">5</span>] = <span class="pl-k">half2</span>(-<span class="pl-c1">1</span>, -ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[<span class="pl-c1">6</span>] = <span class="pl-k">half2</span>(<span class="pl-c1">0</span>, -ratio_w_h) * _OutlineWidth;
                Output.offsets[<span class="pl-c1">7</span>] = <span class="pl-k">half2</span>(<span class="pl-c1">1</span>, -ratio_w_h) * _OutlineWidth * multipty_num_2;

                <span class="pl-k">return</span> Output;
            }



            <span class="pl-k">half4</span> <span class="pl-c1">frag</span>(Varyings IN) : <span class="pl-c1">SV_Target</span>
            {
                <span class="pl-k">const</span> <span class="pl-k">half</span> kernelX[<span class="pl-c1">8</span>] =
                {
                    - <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>,
                    - <span class="pl-c1">2</span>, <span class="pl-c1">2</span>,
                    - <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>
                };

                <span class="pl-k">const</span> <span class="pl-k">half</span> kernelY[<span class="pl-c1">8</span>] =
                {
                    - <span class="pl-c1">1</span>, -<span class="pl-c1">2</span>, -<span class="pl-c1">1</span>,
                    <span class="pl-c1">0</span>, <span class="pl-c1">0</span>,
                    <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">1</span>
                };


                <span class="pl-k">half</span> gx = <span class="pl-c1">0</span>;
                <span class="pl-k">half</span> gy = <span class="pl-c1">0</span>;
                <span class="pl-k">half</span> multiply_num = <span class="pl-c1">0</span>;

                <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">8</span>; i++)
                {
                    multiply_num = <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_Outline3D, sampler_linear_clamp_Outline3D, IN.uv + IN.offsets[i]).a;
                    gx += multiply_num * kernelX[i];
                    gy += multiply_num * kernelY[i];
                }

                <span class="pl-k">const</span> <span class="pl-k">half</span> _a = <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_Outline3D, sampler_linear_clamp_Outline3D, IN.uv).a;
                <span class="pl-k">half4</span> col = _OutlineColor;
                col.a = <span class="pl-c1">saturate</span>(<span class="pl-c1">abs</span>(gx) + <span class="pl-c1">abs</span>(gy)) * (<span class="pl-c1">1</span> - _a);

                
                <span class="pl-k">return</span> col;
            }

            ENDHLSL
        }
    }
}</pre></div>
</details>
<h5>后处理Feature2</h5>
<details>
	<summary>URP_Feature_Outline3D_2</summary>
<div class="highlight highlight-source-cs"><pre class="notranslate"><span class="pl-k">using</span> <span class="pl-s1">System</span><span class="pl-kos">.</span><span class="pl-s1">Collections</span><span class="pl-kos">.</span><span class="pl-s1">Generic</span><span class="pl-kos">;</span>
<span class="pl-k">using</span> <span class="pl-s1">UnityEngine</span><span class="pl-kos">;</span>
<span class="pl-k">using</span> <span class="pl-s1">UnityEngine</span><span class="pl-kos">.</span><span class="pl-s1">Rendering</span><span class="pl-kos">;</span>
<span class="pl-k">using</span> <span class="pl-s1">UnityEngine</span><span class="pl-kos">.</span><span class="pl-s1">Rendering</span><span class="pl-kos">.</span><span class="pl-s1">RendererUtils</span><span class="pl-kos">;</span>
<span class="pl-k">using</span> <span class="pl-s1">UnityEngine</span><span class="pl-kos">.</span><span class="pl-s1">Rendering</span><span class="pl-kos">.</span><span class="pl-s1">Universal</span><span class="pl-kos">;</span>
<span class="pl-k">using</span> <span class="pl-s1">UnityEngine</span><span class="pl-kos">.</span><span class="pl-s1">Serialization</span><span class="pl-kos">;</span>

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">URP_Feature_Outline3D_2</span> <span class="pl-c1">:</span> <span class="pl-smi">ScriptableRendererFeature</span>
<span class="pl-kos">{</span>
    <span class="pl-k">private</span> <span class="pl-k">class</span> <span class="pl-smi">Outline3DRenderPass</span> <span class="pl-c1">:</span> <span class="pl-smi">ScriptableRenderPass</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">private</span> <span class="pl-k"><span class="pl-k">static</span></span> <span class="pl-k">readonly</span> <span class="pl-smi">List</span><span class="pl-c1">&lt;</span><span class="pl-smi">ShaderTagId</span><span class="pl-c1">&gt;</span> <span class="pl-s1">s_shaderTagIds</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">List</span><span class="pl-c1">&lt;</span><span class="pl-smi">ShaderTagId</span><span class="pl-c1">&gt;</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-k">new</span> <span class="pl-smi">ShaderTagId</span><span class="pl-kos">(</span><span class="pl-s">"UniversalForward"</span><span class="pl-kos">)</span><span class="pl-kos">,</span>
            <span class="pl-k">new</span> <span class="pl-smi">ShaderTagId</span><span class="pl-kos">(</span><span class="pl-s">"UniversalForwardOnly"</span><span class="pl-kos">)</span><span class="pl-kos">,</span>
            <span class="pl-k">new</span> <span class="pl-smi">ShaderTagId</span><span class="pl-kos">(</span><span class="pl-s">"SRPDefaultUnlit"</span><span class="pl-kos">)</span>
        <span class="pl-kos">}</span><span class="pl-kos">;</span>
        
        
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-smi">Material</span> <span class="pl-s1">m_outline_material</span><span class="pl-kos">;</span>
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-smi">Color</span> <span class="pl-s1">m_outlineColor</span> <span class="pl-c1">=</span> <span class="pl-s1">Color</span><span class="pl-kos">.</span><span class="pl-s1">yellow</span><span class="pl-kos">;</span>
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-smi">float</span> <span class="pl-s1">m_downSampleScale</span> <span class="pl-c1">=</span> <span class="pl-c1">0.5f</span><span class="pl-kos">;</span> 
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-smi">int</span> <span class="pl-s1">m_blurIterations</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span> 
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-smi">float</span> <span class="pl-s1">m_blurWidth</span> <span class="pl-c1">=</span> <span class="pl-c1">1.0f</span><span class="pl-kos">;</span>
        
        
        
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-smi">FilteringSettings</span> <span class="pl-s1">m_filteringSettings</span><span class="pl-kos">;</span>
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-smi">MaterialPropertyBlock</span> <span class="pl-s1">m_materialPropertyBlock</span><span class="pl-kos">;</span>
        
        <span class="pl-k">private</span> <span class="pl-smi">RTHandle</span> <span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">;</span>
        <span class="pl-k">private</span> <span class="pl-smi">RTHandle</span> <span class="pl-s1">m_temp_downsample_rtHandle</span><span class="pl-kos">;</span>
        <span class="pl-k">private</span> <span class="pl-smi">RTHandle</span> <span class="pl-s1">m_temp_blurRt</span><span class="pl-kos">;</span>

        <span class="pl-k">public</span> <span class="pl-v">Outline3DRenderPass</span><span class="pl-kos">(</span><span class="pl-smi">Material</span> <span class="pl-s1">material</span><span class="pl-kos">,</span><span class="pl-smi">Color</span> <span class="pl-s1">outlineColor</span><span class="pl-kos">,</span><span class="pl-smi">float</span> <span class="pl-s1">downSampleScale</span><span class="pl-kos">,</span><span class="pl-smi">int</span> <span class="pl-s1">blurIterations</span><span class="pl-kos">,</span><span class="pl-smi">float</span> <span class="pl-s1">blurWidth</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-c">// Configures where the render pass should be injected.</span>
            <span class="pl-s1">renderPassEvent</span> <span class="pl-c1">=</span> <span class="pl-s1">RenderPassEvent</span><span class="pl-kos">.</span><span class="pl-s1">AfterRenderingPostProcessing</span><span class="pl-kos">;</span>

            <span class="pl-s1">m_outline_material</span> <span class="pl-c1">=</span> <span class="pl-s1">material</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_outlineColor</span> <span class="pl-c1">=</span> <span class="pl-s1">outlineColor</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_downSampleScale</span> <span class="pl-c1">=</span> <span class="pl-s1">downSampleScale</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_blurIterations</span> <span class="pl-c1">=</span> <span class="pl-s1">blurIterations</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_blurWidth</span> <span class="pl-c1">=</span> <span class="pl-s1">blurWidth</span><span class="pl-kos">;</span>
            
            <span class="pl-s1">m_filteringSettings</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">FilteringSettings</span><span class="pl-kos">(</span><span class="pl-s1">RenderQueueRange</span><span class="pl-kos">.</span><span class="pl-s1">all</span><span class="pl-kos">,</span> <span class="pl-s1">renderingLayerMask</span><span class="pl-c1">:</span> <span class="pl-c1">0b10</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_materialPropertyBlock</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">MaterialPropertyBlock</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>


        <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">Dispose</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-s1">m_outline_rtHandle</span><span class="pl-c1">?</span><span class="pl-kos">.</span><span class="pl-s1">Release</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_outline_rtHandle</span> <span class="pl-c1">=</span> <span class="pl-c1">null</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_temp_blurRt</span><span class="pl-c1">?</span><span class="pl-kos">.</span><span class="pl-s1">Release</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_temp_blurRt</span> <span class="pl-c1">=</span> <span class="pl-c1">null</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_temp_downsample_rtHandle</span><span class="pl-c1">?</span><span class="pl-kos">.</span><span class="pl-s1">Release</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_temp_downsample_rtHandle</span> <span class="pl-c1">=</span> <span class="pl-c1">null</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>




        <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">OnCameraSetup</span><span class="pl-kos">(</span><span class="pl-smi">CommandBuffer</span> <span class="pl-s1">cmd</span><span class="pl-kos">,</span> <span class="pl-k">ref</span> <span class="pl-smi">RenderingData</span> <span class="pl-s1">renderingData</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>

            <span class="pl-k">var</span> <span class="pl-s1">desc_camera</span> <span class="pl-c1">=</span> <span class="pl-s1">renderingData</span><span class="pl-kos">.</span><span class="pl-s1">cameraData</span><span class="pl-kos">.</span><span class="pl-s1">cameraTargetDescriptor</span><span class="pl-kos">;</span>
            <span class="pl-s1">desc_camera</span><span class="pl-kos">.</span><span class="pl-s1">msaaSamples</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>
            <span class="pl-s1">desc_camera</span><span class="pl-kos">.</span><span class="pl-s1">depthBufferBits</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span><span class="pl-kos">;</span>
            <span class="pl-s1">desc_camera</span><span class="pl-kos">.</span><span class="pl-s1">colorFormat</span> <span class="pl-c1">=</span> <span class="pl-s1">RenderTextureFormat</span><span class="pl-kos">.</span><span class="pl-s1">ARGB32</span><span class="pl-kos">;</span>
            <span class="pl-s1">RenderingUtils</span><span class="pl-kos">.</span><span class="pl-en">ReAllocateIfNeeded</span><span class="pl-kos">(</span><span class="pl-k">ref</span> <span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">,</span> <span class="pl-s1">desc_camera</span><span class="pl-kos">,</span> <span class="pl-s1">name</span><span class="pl-c1">:</span> <span class="pl-s">"_Outline3D"</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            
            <span class="pl-smi">Vector2</span> <span class="pl-s1">scaleFactor</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">Vector2</span><span class="pl-kos">(</span><span class="pl-s1">m_downSampleScale</span><span class="pl-kos">,</span> <span class="pl-s1">m_downSampleScale</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">RenderingUtils</span><span class="pl-kos">.</span><span class="pl-en">ReAllocateIfNeeded</span><span class="pl-kos">(</span><span class="pl-k">ref</span> <span class="pl-s1">m_temp_downsample_rtHandle</span><span class="pl-kos">,</span><span class="pl-s1">scaleFactor</span><span class="pl-kos">,</span><span class="pl-s1">desc_camera</span> <span class="pl-kos">,</span><span class="pl-s1">name</span><span class="pl-c1">:</span> <span class="pl-s">"_TempDownsample"</span><span class="pl-kos">,</span><span class="pl-s1">filterMode</span><span class="pl-c1">:</span><span class="pl-s1">FilterMode</span><span class="pl-kos">.</span><span class="pl-s1">Bilinear</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">RenderingUtils</span><span class="pl-kos">.</span><span class="pl-en">ReAllocateIfNeeded</span><span class="pl-kos">(</span><span class="pl-k">ref</span> <span class="pl-s1">m_temp_blurRt</span><span class="pl-kos">,</span><span class="pl-s1">scaleFactor</span><span class="pl-kos">,</span><span class="pl-s1">desc_camera</span> <span class="pl-kos">,</span><span class="pl-s1">name</span><span class="pl-c1">:</span> <span class="pl-s">"_TempBlur"</span><span class="pl-kos">,</span><span class="pl-s1">filterMode</span><span class="pl-c1">:</span><span class="pl-s1">FilterMode</span><span class="pl-kos">.</span><span class="pl-s1">Bilinear</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>
        
        <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">Execute</span><span class="pl-kos">(</span><span class="pl-smi">ScriptableRenderContext</span> <span class="pl-s1">context</span><span class="pl-kos">,</span> <span class="pl-k">ref</span> <span class="pl-smi">RenderingData</span> <span class="pl-s1">renderingData</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-k">var</span> <span class="pl-s1">cameraData</span> <span class="pl-c1">=</span> <span class="pl-s1">renderingData</span><span class="pl-kos">.</span><span class="pl-s1">cameraData</span><span class="pl-kos">;</span>
            <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">cameraData</span><span class="pl-kos">.</span><span class="pl-s1">camera</span><span class="pl-kos">.</span><span class="pl-s1">cameraType</span> <span class="pl-c1">!=</span> <span class="pl-s1">CameraType</span><span class="pl-kos">.</span><span class="pl-s1">Game</span><span class="pl-kos">)</span>
                <span class="pl-k">return</span><span class="pl-kos">;</span>

            <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">m_outline_material</span> <span class="pl-c1">==</span> <span class="pl-c1">null</span><span class="pl-kos">)</span>
                <span class="pl-k">return</span><span class="pl-kos">;</span>
            
            
            
            
            <span class="pl-k">var</span> <span class="pl-s1">cmd</span> <span class="pl-c1">=</span> <span class="pl-s1">CommandBufferPool</span><span class="pl-kos">.</span><span class="pl-en">Get</span><span class="pl-kos">(</span><span class="pl-s">"Outline3D CMD"</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

            <span class="pl-c">// CMD</span>
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">SetRenderTarget</span><span class="pl-kos">(</span><span class="pl-s1">m_temp_downsample_rtHandle</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">ClearRenderTarget</span><span class="pl-kos">(</span><span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-s1">Color</span><span class="pl-kos">.</span><span class="pl-s1">clear</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">SetRenderTarget</span><span class="pl-kos">(</span><span class="pl-s1">m_temp_blurRt</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">ClearRenderTarget</span><span class="pl-kos">(</span><span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-s1">Color</span><span class="pl-kos">.</span><span class="pl-s1">clear</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">SetRenderTarget</span><span class="pl-kos">(</span><span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">ClearRenderTarget</span><span class="pl-kos">(</span><span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-s1">Color</span><span class="pl-kos">.</span><span class="pl-s1">clear</span><span class="pl-kos">)</span><span class="pl-kos">;</span>


            <span class="pl-k">var</span> <span class="pl-s1">draw_settings</span> <span class="pl-c1">=</span> <span class="pl-s1">CreateDrawingSettings</span><span class="pl-kos">(</span><span class="pl-s1">s_shaderTagIds</span><span class="pl-kos">,</span> <span class="pl-k">ref</span> <span class="pl-s1">renderingData</span><span class="pl-kos">,</span> <span class="pl-s1">SortingCriteria</span><span class="pl-kos">.</span><span class="pl-s1">None</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-smi">RendererListParams</span> <span class="pl-s1">rendererListParams</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">RendererListParams</span><span class="pl-kos">(</span><span class="pl-s1">renderingData</span><span class="pl-kos">.</span><span class="pl-s1">cullResults</span><span class="pl-kos">,</span> <span class="pl-s1">draw_settings</span><span class="pl-kos">,</span> <span class="pl-s1">m_filteringSettings</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-k">var</span> <span class="pl-s1">list_draw</span> <span class="pl-c1">=</span> <span class="pl-s1">context</span><span class="pl-kos">.</span><span class="pl-en">CreateRendererList</span><span class="pl-kos">(</span><span class="pl-k">ref</span> <span class="pl-s1">rendererListParams</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">DrawRendererList</span><span class="pl-kos">(</span><span class="pl-s1">list_draw</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

            
            
            
            <span class="pl-c">// Pass0</span>
            <span class="pl-s1">m_outline_material</span><span class="pl-kos">.</span><span class="pl-en">SetColor</span><span class="pl-kos">(</span><span class="pl-s">"_OutlineColor"</span><span class="pl-kos">,</span> <span class="pl-s1">m_outlineColor</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">Blitter</span><span class="pl-kos">.</span><span class="pl-en">BlitCameraTexture</span><span class="pl-kos">(</span><span class="pl-s1">cmd</span><span class="pl-kos">,</span> <span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">,</span><span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">,</span><span class="pl-s1">m_outline_material</span><span class="pl-kos">,</span><span class="pl-c1">0</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">m_outline_material</span><span class="pl-kos">.</span><span class="pl-en">SetTexture</span><span class="pl-kos">(</span><span class="pl-s">"_OutlineColorTex"</span><span class="pl-kos">,</span> <span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

            
            
            <span class="pl-c">// Pass1</span>
            <span class="pl-s1">m_outline_material</span><span class="pl-kos">.</span><span class="pl-en">SetFloat</span><span class="pl-kos">(</span><span class="pl-s">"_BlurWidth"</span><span class="pl-kos">,</span> <span class="pl-s1">m_blurWidth</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-k">for</span> <span class="pl-kos">(</span><span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span><span class="pl-kos">;</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">m_blurIterations</span><span class="pl-kos">;</span> <span class="pl-c1">++</span><span class="pl-s1">i</span><span class="pl-kos">)</span>
            <span class="pl-kos">{</span>
                <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">i</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span><span class="pl-kos">)</span>
                <span class="pl-kos">{</span>
                    <span class="pl-s1">Blitter</span><span class="pl-kos">.</span><span class="pl-en">BlitCameraTexture</span><span class="pl-kos">(</span><span class="pl-s1">cmd</span><span class="pl-kos">,</span> <span class="pl-s1">m_outline_rtHandle</span><span class="pl-kos">,</span><span class="pl-s1">m_temp_downsample_rtHandle</span><span class="pl-kos">,</span><span class="pl-s1">m_outline_material</span><span class="pl-kos">,</span><span class="pl-c1">1</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
                    <span class="pl-s1">Blitter</span><span class="pl-kos">.</span><span class="pl-en">BlitCameraTexture</span><span class="pl-kos">(</span><span class="pl-s1">cmd</span><span class="pl-kos">,</span> <span class="pl-s1">m_temp_downsample_rtHandle</span><span class="pl-kos">,</span><span class="pl-s1">m_temp_blurRt</span><span class="pl-kos">,</span><span class="pl-s1">m_outline_material</span><span class="pl-kos">,</span><span class="pl-c1">1</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
                <span class="pl-kos">}</span>
                <span class="pl-k">else</span>
                <span class="pl-kos">{</span>
                    <span class="pl-s1">Blitter</span><span class="pl-kos">.</span><span class="pl-en">BlitCameraTexture</span><span class="pl-kos">(</span><span class="pl-s1">cmd</span><span class="pl-kos">,</span> <span class="pl-s1">m_temp_blurRt</span><span class="pl-kos">,</span><span class="pl-s1">m_temp_downsample_rtHandle</span><span class="pl-kos">,</span><span class="pl-s1">m_outline_material</span><span class="pl-kos">,</span><span class="pl-c1">1</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
                    <span class="pl-s1">Blitter</span><span class="pl-kos">.</span><span class="pl-en">BlitCameraTexture</span><span class="pl-kos">(</span><span class="pl-s1">cmd</span><span class="pl-kos">,</span> <span class="pl-s1">m_temp_downsample_rtHandle</span><span class="pl-kos">,</span><span class="pl-s1">m_temp_blurRt</span><span class="pl-kos">,</span><span class="pl-s1">m_outline_material</span><span class="pl-kos">,</span><span class="pl-c1">1</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
                <span class="pl-kos">}</span>
            <span class="pl-kos">}</span>
            
            

            <span class="pl-c">// Pass2</span>
            <span class="pl-s1">m_outline_material</span><span class="pl-kos">.</span><span class="pl-en">SetTexture</span><span class="pl-kos">(</span><span class="pl-s">"_BlurTex"</span><span class="pl-kos">,</span> <span class="pl-s1">m_temp_blurRt</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            
            
            <span class="pl-smi">RTHandle</span> <span class="pl-s1">targetRT</span> <span class="pl-c1">=</span> <span class="pl-s1">cameraData</span><span class="pl-kos">.</span><span class="pl-s1">renderer</span><span class="pl-kos">.</span><span class="pl-s1">cameraColorTargetHandle</span><span class="pl-kos">;</span>
            <span class="pl-s1">Blitter</span><span class="pl-kos">.</span><span class="pl-en">BlitCameraTexture</span><span class="pl-kos">(</span><span class="pl-s1">cmd</span><span class="pl-kos">,</span> <span class="pl-s1">targetRT</span><span class="pl-kos">,</span><span class="pl-s1">targetRT</span><span class="pl-kos">,</span><span class="pl-s1">m_outline_material</span><span class="pl-kos">,</span><span class="pl-c1">2</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            
            
            <span class="pl-s1">context</span><span class="pl-kos">.</span><span class="pl-en">ExecuteCommandBuffer</span><span class="pl-kos">(</span><span class="pl-s1">cmd</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">cmd</span><span class="pl-kos">.</span><span class="pl-en">Clear</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
            <span class="pl-s1">CommandBufferPool</span><span class="pl-kos">.</span><span class="pl-en">Release</span><span class="pl-kos">(</span><span class="pl-s1">cmd</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>

        
        <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">OnCameraCleanup</span><span class="pl-kos">(</span><span class="pl-smi">CommandBuffer</span> <span class="pl-s1">cmd</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            
        <span class="pl-kos">}</span>
    <span class="pl-kos">}</span>






    <span class="pl-kos">[</span><span class="pl-c1">SerializeField</span><span class="pl-kos">]</span> <span class="pl-k">private</span> <span class="pl-smi">Material</span> <span class="pl-s1">m_OutlineMaterial</span><span class="pl-kos">;</span>
    <span class="pl-k">public</span> <span class="pl-smi">Color</span> <span class="pl-s1">m_outlineColor</span> <span class="pl-c1">=</span> <span class="pl-s1">Color</span><span class="pl-kos">.</span><span class="pl-s1">yellow</span><span class="pl-kos">;</span>

    <span class="pl-kos">[</span><span class="pl-c1">Range</span><span class="pl-kos">(</span><span class="pl-c1">0.1f</span><span class="pl-kos">,</span> <span class="pl-c1">1</span><span class="pl-kos">)</span><span class="pl-kos">]</span>
    <span class="pl-k">public</span> <span class="pl-smi">float</span> <span class="pl-s1">m_downSampleScale</span> <span class="pl-c1">=</span> <span class="pl-c1">0.5f</span><span class="pl-kos">;</span>                 <span class="pl-c">// 降采样比例</span>
    <span class="pl-kos">[</span><span class="pl-c1">Range</span><span class="pl-kos">(</span><span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">4</span><span class="pl-kos">)</span><span class="pl-kos">]</span>
    <span class="pl-k">public</span> <span class="pl-smi">int</span> <span class="pl-s1">m_blurIterations</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>                  <span class="pl-c">// 均值糊迭代次数</span>
    <span class="pl-kos">[</span><span class="pl-c1">FormerlySerializedAs</span><span class="pl-kos">(</span><span class="pl-s">"m_blurRadius"</span><span class="pl-kos">)</span><span class="pl-kos">]</span> <span class="pl-kos">[</span><span class="pl-c1">Range</span> <span class="pl-kos">(</span><span class="pl-c1">0.2f</span><span class="pl-kos">,</span> <span class="pl-c1">10.0f</span><span class="pl-kos">)</span><span class="pl-kos">]</span>
    <span class="pl-k">public</span> <span class="pl-smi">float</span> <span class="pl-s1">m_blurWidth</span> <span class="pl-c1">=</span> <span class="pl-c1">1.0f</span><span class="pl-kos">;</span>
    
    <span class="pl-k">private</span> <span class="pl-smi">bool</span> <span class="pl-s1">IsMaterialValid</span> <span class="pl-c1">=&gt;</span> <span class="pl-s1">m_OutlineMaterial</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">m_OutlineMaterial</span><span class="pl-kos">.</span><span class="pl-s1">shader</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">m_OutlineMaterial</span><span class="pl-kos">.</span><span class="pl-s1">shader</span><span class="pl-kos">.</span><span class="pl-s1">isSupported</span><span class="pl-kos">;</span>

    
    
    
    <span class="pl-k">private</span> <span class="pl-smi">Outline3DRenderPass</span> <span class="pl-s1">m_Outline3DScriptablePass</span><span class="pl-kos">;</span>
    

    <span class="pl-c">/// &lt;inheritdoc/&gt;</span>
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">Create</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-c1">!</span><span class="pl-s1">IsMaterialValid</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-k">return</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>

        <span class="pl-s1">m_Outline3DScriptablePass</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-smi">Outline3DRenderPass</span><span class="pl-kos">(</span><span class="pl-s1">m_OutlineMaterial</span><span class="pl-kos">,</span><span class="pl-s1">m_outlineColor</span><span class="pl-kos">,</span><span class="pl-s1">m_downSampleScale</span><span class="pl-kos">,</span><span class="pl-s1">m_blurIterations</span><span class="pl-kos">,</span><span class="pl-s1">m_blurWidth</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>
    
    
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">AddRenderPasses</span><span class="pl-kos">(</span><span class="pl-smi">ScriptableRenderer</span> <span class="pl-s1">renderer</span><span class="pl-kos">,</span> <span class="pl-k">ref</span> <span class="pl-smi">RenderingData</span> <span class="pl-s1">renderingData</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">m_Outline3DScriptablePass</span> <span class="pl-c1">==</span> <span class="pl-c1">null</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-k">return</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>

        <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">renderingData</span><span class="pl-kos">.</span><span class="pl-s1">cameraData</span><span class="pl-kos">.</span><span class="pl-s1">cameraType</span> <span class="pl-c1">==</span> <span class="pl-s1">CameraType</span><span class="pl-kos">.</span><span class="pl-s1">Game</span><span class="pl-kos">)</span>
        <span class="pl-kos">{</span>
            <span class="pl-s1">renderer</span><span class="pl-kos">.</span><span class="pl-en">EnqueuePass</span><span class="pl-kos">(</span><span class="pl-s1">m_Outline3DScriptablePass</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>
    <span class="pl-kos">}</span>


    <span class="pl-k">protected</span> <span class="pl-k">override</span> <span class="pl-smi">void</span> <span class="pl-en">Dispose</span><span class="pl-kos">(</span><span class="pl-smi">bool</span> <span class="pl-s1">disposing</span><span class="pl-kos">)</span>
    <span class="pl-kos">{</span>
        <span class="pl-s1">m_Outline3DScriptablePass</span><span class="pl-c1">?</span><span class="pl-kos">.</span><span class="pl-s1">Dispose</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>

<span class="pl-kos">}</span></pre></div>
</details>
<details>
	<summary>PostEffectOutline3D</summary>
<div class="highlight highlight-source-hlsl"><pre class="notranslate">Shader <span class="pl-s">"URP/PostEffectOutline3D"</span>
{
    Properties
    {
    	[PerRendererData]<span class="pl-c1">_OutlineColor</span> (<span class="pl-s">"Outline Color"</span>,Color) = (<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>)
    	[PerRendererData]<span class="pl-c1">_BlurRadius</span>(<span class="pl-s">"Blur Width"</span>,Float) = <span class="pl-c1">1</span>
    }
    SubShader
    {
        Tags
        {
            <span class="pl-s">"RenderType"</span>=<span class="pl-s">"Opaque"</span>
            <span class="pl-s">"RenderPipeline"</span>=<span class="pl-s">"UniversalPipeline"</span>
            <span class="pl-s">"IgnoreProjector"</span>=<span class="pl-s">"true"</span>
        	<span class="pl-s">"Queue"</span> = <span class="pl-s">"Geometry"</span>
        }
        LOD <span class="pl-c1">100</span>
		Cull Off 
		ZWrite Off
	    Blend SrcAlpha OneMinusSrcAlpha
        
        HLSLINCLUDE
        
<span class="pl-k">        #include</span> <span class="pl-s">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"</span>
<span class="pl-k">        #include</span> <span class="pl-s">"Packages/com.unity.render-pipelines.core/Runtime/Utilities/Blit.hlsl"</span>
        
        <span class="pl-c1">TEXTURE2D_X</span>(_CameraOpaqueTexture);
        <span class="pl-c1">TEXTURE2D_X</span>(_OutlineColorTex);
        <span class="pl-c1">TEXTURE2D_X</span>(_BlurTex);
        <span class="pl-c1">SAMPLER</span>(sampler_linear_clamp_CameraOpaqueTexture);

        <span class="pl-k">half4</span> _BlitTexture_TexelSize;
        <span class="pl-c1">CBUFFER_START</span>(UnityPerMaterial)
            <span class="pl-k">half4</span> _OutlineColor;
		    <span class="pl-k">float</span> _BlurWidth;
        CBUFFER_END


        <span class="pl-k">struct</span> appdata_img
        {
	        <span class="pl-k">half4</span> vertex : <span class="pl-c1">POSITION</span>;
        	<span class="pl-k">half2</span> texcoord : <span class="pl-c1">TEXCOORD0</span>;
        };

        
        <span class="pl-k">struct</span> v2f
		{
			<span class="pl-k">float4</span> pos : <span class="pl-c1">SV_POSITION</span>;
			<span class="pl-k">half2</span> uv_ : <span class="pl-c1">TEXCOORD0</span>;
			<span class="pl-k">half4</span> uv1 : <span class="pl-c1">TEXCOORD3</span>;
			<span class="pl-k">half4</span> uv2 : <span class="pl-c1">TEXCOORD4</span>;
			<span class="pl-k">half4</span> uv3 : <span class="pl-c1">TEXCOORD5</span>;
			<span class="pl-k">half4</span> uv4 : <span class="pl-c1">TEXCOORD6</span>;
		};
        
        

        <span class="pl-c">// 均值模糊</span>
        <span class="pl-c">// ---------------------------【顶点着色器】---------------------------</span>
        v2f <span class="pl-c1">vert_average</span>(appdata_img v,<span class="pl-k">uint</span> vid : <span class="pl-c1">SV_VertexID</span>)  
        {  
            v2f o;  
            o.pos = <span class="pl-c1">GetFullScreenTriangleVertexPosition</span>(vid); <span class="pl-c">//TransformObjectToHClip(v.vertex);  </span>
            <span class="pl-c">//uv坐标  </span>
            o.uv_ = <span class="pl-c1">GetFullScreenTriangleTexCoord</span>(vid); <span class="pl-c">//v.texcoord.xy;  </span>
            <span class="pl-c">//计算周围的8个uv坐标</span>
            o.uv1.xy = o.uv_ + _BlitTexture_TexelSize.xy * <span class="pl-k">float2</span>(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>) * _BlurWidth;  
            o.uv1.zw = o.uv_ + _BlitTexture_TexelSize.xy * <span class="pl-k">float2</span>(-<span class="pl-c1">1</span>, <span class="pl-c1">0</span>) * _BlurWidth;
            
            o.uv2.xy = o.uv_ + _BlitTexture_TexelSize.xy * <span class="pl-k">float2</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>) * _BlurWidth;
            o.uv2.zw = o.uv_ + _BlitTexture_TexelSize.xy * <span class="pl-k">float2</span>(<span class="pl-c1">0</span>, -<span class="pl-c1">1</span>) * _BlurWidth;
            
            o.uv3.xy = o.uv_ + _BlitTexture_TexelSize.xy * <span class="pl-k">float2</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>) * _BlurWidth;
            o.uv3.zw = o.uv_ + _BlitTexture_TexelSize.xy * <span class="pl-k">float2</span>(-<span class="pl-c1">1</span>, <span class="pl-c1">1</span>) * _BlurWidth;
            
            o.uv4.xy = o.uv_ + _BlitTexture_TexelSize.xy * <span class="pl-k">float2</span>(<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>) * _BlurWidth;
            o.uv4.zw = o.uv_ + _BlitTexture_TexelSize.xy * <span class="pl-k">float2</span>(-<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>) * _BlurWidth;
            <span class="pl-k">return</span> o;  
        }  
        
        <span class="pl-c">// ---------------------------【片元着色器】---------------------------</span>
        <span class="pl-k">half4</span> <span class="pl-c1">frag_average</span>(v2f i) : <span class="pl-c1">SV_Target</span>  
        {  
            <span class="pl-k">half4</span> color = <span class="pl-k">half4</span>(<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>);  
            color += <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_.xy);
            color += <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv1.xy);
            color += <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv1.zw);
            color += <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv2.xy);
            color += <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv2.zw);
            color += <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv3.xy);
            color += <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv3.zw);
            color += <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv4.xy);
            color += <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv4.zw);
            <span class="pl-c">// 取平均值</span>
            <span class="pl-k">return</span> color / <span class="pl-c1">9</span>;
        }
        
        
        ENDHLSL
        
        Pass
        {
            HLSLPROGRAM

<span class="pl-k">            #pragma</span> vertex vert
<span class="pl-k">			#pragma</span> fragment frag
            
            v2f <span class="pl-c1">vert</span> (appdata_img v,<span class="pl-k">uint</span> vid : <span class="pl-c1">SV_VertexID</span>)
            {
                v2f o;
				o.uv_ = <span class="pl-c1">GetFullScreenTriangleTexCoord</span>(vid); <span class="pl-c">//v.texcoord;</span>
        		o.pos = <span class="pl-c1">GetFullScreenTriangleVertexPosition</span>(vid); <span class="pl-c">//TransformObjectToHClip(v.vertex);</span>
                <span class="pl-k">return</span> o;
            }

            <span class="pl-k">half4</span> <span class="pl-c1">frag</span> (v2f i) : <span class="pl-c1">SV_Target</span>
            {
            	<span class="pl-k">half4</span> col = <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
            	<span class="pl-c1">clip</span>(col.r - <span class="pl-c1">0.1f</span>);
            	<span class="pl-k">return</span> _OutlineColor;
            }
            
           ENDHLSL
        }


        Pass
        {
            HLSLPROGRAM

<span class="pl-k">            #pragma</span> vertex vert_average
<span class="pl-k">			#pragma</span> fragment frag_average
            
            ENDHLSL
        }




        Pass
        {
            HLSLPROGRAM

<span class="pl-k">            #pragma</span> vertex vert;
<span class="pl-k">            #pragma</span> fragment frag;

            v2f <span class="pl-c1">vert</span>(appdata_img v,<span class="pl-k">uint</span> vid : <span class="pl-c1">SV_VertexID</span>)
            {
                v2f o;
                o.pos = <span class="pl-c1">GetFullScreenTriangleVertexPosition</span>(vid); <span class="pl-c">//TransformObjectToHClip(v.vertex);</span>
                o.uv_ = <span class="pl-c1">GetFullScreenTriangleTexCoord</span>(vid); <span class="pl-c">//v.texcoord;</span>
                <span class="pl-k">return</span> o;
            }
            

			<span class="pl-k">half4</span> <span class="pl-c1">frag</span>(v2f i) : <span class="pl-c1">SV_Target</span>
			{
				<span class="pl-k">half4</span> scene = <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
				<span class="pl-k">half4</span> blur = <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_BlurTex, sampler_linear_clamp_CameraOpaqueTexture,i.uv_);
				<span class="pl-k">half4</span> outlieColor = <span class="pl-c1">SAMPLE_TEXTURE2D_X</span>(_OutlineColorTex,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
				<span class="pl-k">half4</span> o = outlieColor - blur;

				<span class="pl-k">half</span> sign = <span class="pl-c1">step</span>(<span class="pl-c1">0.</span>01h,o.a);
				<span class="pl-k">half4</span> colMix = <span class="pl-c1">lerp</span>(scene,_OutlineColor,o.a);
				<span class="pl-k">return</span> scene * (<span class="pl-c1">1</span>-sign) + sign * colMix;
			}
            
            ENDHLSL
        }
        

    }
}
</pre></div>
</details></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://ogazen.github.io">Gazen's Blog</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.disabled=true;
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","oGazen/ogazen.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://ogazen.github.io/plugins/GmeekTOC.js'></script>

</html>
