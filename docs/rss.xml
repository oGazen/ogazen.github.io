<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Gazen's Blog</title><link>https://ogazen.github.io</link><description>欢迎</description><copyright>Gazen's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/68213482?v=4</url><title>avatar</title><link>https://ogazen.github.io</link></image><lastBuildDate>Wed, 24 Dec 2025 03:40:47 +0000</lastBuildDate><managingEditor>Gazen's Blog</managingEditor><ttl>60</ttl><webMaster>Gazen's Blog</webMaster><item><title>AI(vLLM,Ollama,Open WebUI)</title><link>https://ogazen.github.io/post/AI%28vLLM%2COllama%2COpen%20WebUI%29.html</link><description>&gt; [!NOTE]
&gt; 平台 WIN10 AMD64 (x64)
&gt; 软件 Dcoker.Desktop
&gt; 显卡 NVIDIA GeForce GTX 1660 SUPER (Driver Version: 560.94; CUDA Version: 12.6)

&gt; [!NOTE]
&gt; Ollama `https://ollama.com/`
&gt; Open WebUI `https://docs.openwebui.com/`
&gt; vLLM `https://docs.vllm.com.cn/`
&gt; huggingface `https://huggingface.co/`
&gt; modelscope `https://www.modelscope.cn/`

&gt; [!NOTE]
&gt; ubuntu 24.04
&gt; python 3.12
&gt; uv `https://docs.astral.ac.cn/`
&gt; venv
&gt; build-essential
&gt; cudatoolkit `https://developer.nvidia.com/cuda-12-6-2-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=24.04&amp;target_type=deb_local`

###### Ollama + Open WebUI

```bash
docker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway \
-v open-webui:/app/backend/data \
--name open-webui \
--restart always \
ghcr.io/open-webui/open-webui:cuda

# --gpus all 映射宿主显卡到容器
# 访问地址 localhost:3000
```

###### vLLM

1. 安装 uv  python环境  vllm [快速入门 - vLLM 文档](https://docs.vllm.com.cn/en/latest/getting_started/quickstart.html#prerequisites)

```bash
uv venv --python 3.12 --seed
source .venv/bin/activate
uv pip install vllm --torch-backend=auto
```

2. 安装 CUDA Toolkit [NVIDIA CUDA Toolkit]([https://](https://developer.nvidia.com/cuda-12-6-2-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=24.04&amp;target_type=deb_local))

```bash
wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2404/x86_64/cuda-ubuntu2404.pin
sudo mv cuda-ubuntu2404.pin /etc/apt/preferences.d/cuda-repository-pin-600
wget https://developer.download.nvidia.com/compute/cuda/12.6.2/local_installers/cuda-repo-ubuntu2404-12-6-local_12.6.2-560.35.03-1_amd64.deb
sudo dpkg -i cuda-repo-ubuntu2404-12-6-local_12.6.2-560.35.03-1_amd64.deb
sudo cp /var/cuda-repo-ubuntu2404-12-6-local/cuda-*-keyring.gpg /usr/share/keyrings/
sudo apt-get update
sudo apt-get -y install cuda-toolkit-12-6
```

3. 设置环境变量

```bash
export VLLM_USE_MODELSCOPE=True
export LD_LIBRARY_PATH=/usr/lcoal/cuda-12.6/lib64:/.venv/lib/python3.12/site-packages/nvidia/cuda_runtime/lib:/.venv/lib/python3.12/site-packages/torch/lib:
export CUDA_HOME=/usr/local/cuda-12.6
export PATH=/usr/local/cuda/bin:$PATH
```

4. 测试运行

```bash
# 下载测试文件并执行
curl -O https://github.com/vllm-project/vllm/blob/main/examples/offline_inference/basic/basic.py
python3 basic.py
```

5. 可能错误和影响

```bash
# vLLM 实例：
llm = LLM(model='facebook/opt-125m',gpu_memory_utilization=0.8)
# gpu_memory_utilization=0.9 显存不足错误
# Free memory on device (5.01/6.0 GiB) on startup is less than desired GPU memory utilization (0.9, 5.4 GiB). Decrease GPU memory utilization or reduce GPU memory used by other processes.
# max_model_len=4069 最大模型长度警告
# To serve at least one request with the models's max seq len (131072), (4.00 GiB KV cache is needed, which is larger than the available KV cache memory (0.65 GiB). Based on the available memory, the estimated maximum model length is 21440. Try increasing `gpu_memory_utilization` or decreasing `max_model_len` when initializing the engine
# swap_space=4 交换空间警告
# Possibly too large swap space. 4.00 GiB out of the 7.72 GiB total CPU memory is allocated for the swap space.

# xxx.so 无法找到
find / -name xxx.so
# 将输出查找到的路径(xxx/lib)写入环境变量即可
export LD_LIBRARY_PATH=path1:$LD_LIBRARY_PATH


# WSL2 警告
# Using 'pin_memory=False' as WSL is detected. This may slow down the performance.

# Compute Capability 显卡版本不支持错误，不影响，会回退支持的方式处理
# Cannot use FA version 2 is not supported due to FA2 is only supported on devices with compute capability &gt;= 8

# uv 错误 trying to connect: invalid peer certificate: UnknownIssuer - Even with SSL_CERT_FILE mapped
uv --native-tls --allow-insecure-host &lt;your url&gt; &lt;your uv command here&gt;

# pip 加速
uv pip install -index=https://mirrors.aliyun.com/pypi/simple/ &lt;your package name&gt;
```

6. 参考链接

* [vllm-project/vllm: A high-throughput and memory-efficient inference and serving engine for LLMs](https://github.com/vllm-project/vllm)
* [Python pip 安装与使用 | 菜鸟教程](https://www.runoob.com/w3cnote/python-pip-install-usage.html)
* [error trying to connect: invalid peer certificate: UnknownIssuer - Even with SSL\_CERT\_FILE mapped · Issue #1819 · astral-sh/uv](https://github.com/astral-sh/uv/issues/1819)
* [uv 安装、国内镜像配置与项目初始化 - 教程 - ljbguanli - 博客园](https://www.cnblogs.com/ljbguanli/p/19357762)
* [解决CUDA环境配置中的\`libcudart.so\`缺失问题-百度开发者中心](https://developer.baidu.com/article/details/3264277)
* [Failed to find C compiler. Please specify via CC environment variable · Issue #2997 · vllm-project/vllm](https://github.com/vllm-project/vllm/issues/2997)
* [解决 Ubuntu 中 /usr/local/cuda 缺失问题及 CUDA Toolkit 12.8 的安装修复过程-CSDN博客](https://blog.csdn.net/gs80140/article/details/147896728)
* [Linux 环境变量](https://cn.linux-terminal.com/?p=8350)
* [Python 网络请求证书验证失败](https://geek-docs.com/python/python-ask-answer/482_python_certificate_verify_failed_unable_to_get_local_issuer_certificate.html)


。</description><guid isPermaLink="true">https://ogazen.github.io/post/AI%28vLLM%2COllama%2COpen%20WebUI%29.html</guid><pubDate>Wed, 24 Dec 2025 03:28:56 +0000</pubDate></item><item><title>Docker.Desktop</title><link>https://ogazen.github.io/post/Docker.Desktop.html</link><description>##### 常用运行命令

```bat
docker run -d -it --name trend-radar
  -v ./config:/app/config:ro
  -v ./output:/app/output
  -e ENV_VARIABLE='VALUE'
  image:tag

# -d 后台运行
# -i 保持一个标准输入流(stdin)打开
# -t 分配一个伪终端
# -v 绑定(相对路劲)
# -e 设置环境变量
# image:tag 镜像和标签
```

```bash
# ubuntu 安装包
apt/apt-get update install xxx
# alpine 安装包
apk udpate add xxx
# 常用包
sudo(执行权限) 
wget(下载) 
curl(下载)
vim(bash修改文件) 
gedit(bash修改文件)
cat(打印文本2bash)
ca-certificates(证书)
```

##### 容器内使用Docker(高权限)

* 运行容器必须绑定 `docker run -v /var/run/docker.sock:/var/run/docker.sock ......`

```bash
##### Ubuntu系统适用 #####
# 运行以下命令，更新软件包索引并安装添加 Docker 仓库所需的前置软件包：
sudo apt update
sudo apt install apt-transport-https curl


# 使用以下命令下载并导入 Docker 官方的 GPG 密钥：
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg


# 将 Docker 的官方仓库添加到 Ubuntu 24.04 LTS 的软件源列表：
echo 'deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release &amp;&amp; echo '$VERSION_CODENAME') stable' | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null


# 刷新软件包列表，以便系统识别新添加的 Docker 仓库：
# 执行以下命令在 Ubuntu 24.04 LTS 上安装最新版本的 Docker，包括 Docker 引擎及其相关组件：
sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

# docker-ce：Docker Engine。</description><guid isPermaLink="true">https://ogazen.github.io/post/Docker.Desktop.html</guid><pubDate>Mon, 15 Dec 2025 05:56:58 +0000</pubDate></item><item><title>汽车汽油发动机维护</title><link>https://ogazen.github.io/post/qi-che-qi-you-fa-dong-ji-wei-hu.html</link><description>##### 保养补充

* 机油、机滤、空气滤芯
* 正时皮带，火花塞
* 轮胎、刹车片、空调滤芯

###### 大众 EA211 1.4TSI

* 正时皮带
* 火花塞+节气门+进气道积碳(核桃砂)
* 水泵+节温器
* 气门室盖 止回阀堵塞  有异响
* 发送机程序升级 气缸失火，轻微抖动
* 燃油泄漏诊断泵 燃油泄漏诊断泵故障(国六 颗粒捕捉器) [P240200 P240700 P043E00 P245000 P240000 P044700 P148D00 P240A00]
* 碳管电磁阀 邮箱排气系统故障[P049600 P044100 P04F00]
* 机油压力调节器、开关、线束 机油容易串到线束中[CSS]



###### 福克斯 1.6L L4 5MT

* 正时皮带   10W公里左右
* 膨胀壶　漏防冻液
* 气门间隙变大 发动机哒哒哒响 很明显
* ABS泵损坏 刹车踏板不回弹或踩不动 制动距离变长
* 方向机渗油

###### 福克斯 1.5T L4 6AT

* 进气歧管机油回流   更换三件套（废弃管，进气歧管，油水分离器）
* 烧防冻液  尾气冒白烟
。</description><guid isPermaLink="true">https://ogazen.github.io/post/qi-che-qi-you-fa-dong-ji-wei-hu.html</guid><pubDate>Thu, 11 Dec 2025 08:04:37 +0000</pubDate></item><item><title>UI扫光、灰化、截屏、适应字符串、贝塞尔曲线、屏幕场景偏移</title><link>https://ogazen.github.io/post/UI-sao-guang-%E3%80%81-hui-hua-%E3%80%81-jie-ping-%E3%80%81-shi-ying-zi-fu-chuan-%E3%80%81-bei-sai-er-qu-xian-%E3%80%81-ping-mu-chang-jing-pian-yi.html</link><description>&lt;details&gt;
&lt;summary&gt;UIScan&lt;/summary&gt;

```hlsl
Shader 'URP/UIScan'
{
    Properties
    {
        [HideInInspector]_MainTex ('Texture', 2D) = 'white' {}
        _Color ('Color',Color) = (1,1,1,1)
        [Toggle] _Reverse('Reverse',Integer) = 0
        
        
        [Header(SCAN)]
        _ScanIntensity('Scan Intensity',Range(0,2)) = 1
        _ScanWidth('Scan Width',Range(0,0.5)) = 0.1
        _ScanAngle('Scan Angle',Range(-89,89)) = 0 // 水平为0
        _Feathering('Feathering',Range(0,1)) = 0
        
        [Header(TIME)]
        _TimeDuration('Time Duration',Range(1,5)) = 1
        _TimeInterval('Time Interval',Range(0,5)) = 1
    }
    SubShader
    {
        Tags
        {
            'RenderType'='Transparent'
            'RenderPipeline'='UniversalPipeline'
            'IgnoreProjector'='true'
            'Queue'='Transparent' // Transparent AlphaTest Geometry Background
        }
        LOD 100
        Blend SrcAlpha OneMinusSrcAlpha

        Pass
        {
            HLSLPROGRAM


            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            #pragma vertex Vert
            #pragma fragment Frag



            TEXTURE2D_X(_MainTex);
            SAMPLER(sampler_MainTex);

            CBUFFER_START(UnityPerMaterial)
            half4 _MainTex_ST;


            half4 _Color;
            
            half _ScanIntensity;
            half _ScanWidth;
            half _ScanAngle;
            half _Feathering;

            half _TimeDuration;
            half _TimeInterval;
            int _Reverse;
            CBUFFER_END

            
            struct Attributes
            {
                half4 position : POSITION;
                half2 uv : TEXCOORD0;
                half4 color : COLOR;
            };


            struct Varyings
            {
                half4 position_sv : SV_POSITION;
                half2 uv : TEXCOORD0;
                half4 color : COLOR;
            };


            Varyings Vert(Attributes IN)
            {
                Varyings OUT;
                OUT.position_sv = TransformObjectToHClip(IN.position);
                OUT.uv = TRANSFORM_TEX(IN.uv,_MainTex);
                OUT.color = IN.color;
                return OUT;
            }



            half4 Frag(Varyings IN) : SV_Target
            {
                half4 col = SAMPLE_TEXTURE2D_X(_MainTex,sampler_MainTex,IN.uv) * IN.color;

                // 时间的变化周期，时间间隔
                half timey = _Time.y;
                half timey_normal = timey % (_TimeDuration + _TimeInterval) / _TimeDuration;
                timey_normal = saturate(timey_normal);


                // 扫描效果
                _ScanAngle = _Reverse==0 ? _ScanAngle : _ScanAngle * -1;
                half k = tan(radians(_ScanAngle));
                half cos_v = cos(radians(_ScanAngle));
                half halfWidth = _ScanWidth / 2 / cos_v;

                half b,y;
                if(k &gt; 0)
                {
                    b = lerp(-halfWidth-k,1+halfWidth,timey_normal);
                    y = k*IN.uv.x + b;
                }
                else
                {
                    b = lerp(-halfWidth,1+halfWidth+abs(k),timey_normal);
                    y = k*IN.uv.x + b;
                }

                
                half y_min = y - halfWidth;
                half y_max = y + halfWidth;
                half uv_y = _Reverse==0 ? IN.uv.y : 1-IN.uv.y;
                if (uv_y &gt;= y_min &amp;&amp; uv_y &lt;= y_max)
                {
                    // 羽化效果
                    half4 colAdd = _Color * _ScanIntensity;
                    half feather = smoothstep(halfWidth,0,abs(uv_y - y));
                    colAdd *= feather;
                    col += colAdd; 
                }
                

                
                return col;
            }
            

            
            ENDHLSL
        }
    }
}
```

&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;UIGray&lt;/summary&gt;

```hlsl
Shader 'URP/UIGray'
{
    Properties
    {
        [HideInInspector]_MainTex ('Texture', 2D) = 'white' {}
    }
    SubShader
    {
        Tags
        {
            'RenderType'='Transparent'
            'RenderPipeline'='UniversalPipeline'
            'IgnoreProjector'='true'
            'Queue'='Transparent' // Transparent AlphaTest Geometry Background
        }
        LOD 100
        Blend SrcAlpha OneMinusSrcAlpha

        Pass
        {
            HLSLPROGRAM


            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            #pragma vertex Vert
            #pragma fragment Frag



            TEXTURE2D_X(_MainTex);
            SAMPLER(sampler_MainTex);

            CBUFFER_START(UnityPerMaterial)
            half4 _MainTex_ST;
            CBUFFER_END

            
            struct Attributes
            {
                half4 position : POSITION;
                half2 uv : TEXCOORD0;
            };


            struct Varyings
            {
                half4 position_sv : SV_POSITION;
                half2 uv : TEXCOORD0;
            };


            Varyings Vert(Attributes IN)
            {
                Varyings OUT;
                OUT.position_sv = TransformObjectToHClip(IN.position);
                OUT.uv = TRANSFORM_TEX(IN.uv,_MainTex);
                return OUT;
            }



            half4 Frag(Varyings IN) : SV_Target
            {
                half4 col = SAMPLE_TEXTURE2D_X(_MainTex,sampler_MainTex,IN.uv);
                const half3 gray_multiply = half3(0.222h, 0.707h, 0.071h);
                col.rgb = dot(col.rgb,gray_multiply);
                return col;
            }
            

            
            ENDHLSL
        }
    }
}

```

&lt;/details&gt;


&lt;details&gt;
&lt;summary&gt;简单截屏&lt;/summary&gt;

```cs
        // 世界坐标转RectTransform本地坐标 
        // RenderMode = Screen Space - Camera
        public static Vector2 WorldPosToRtLocalPos(Vector3 worldpos3, RectTransform rectTransform)
        {
            Camera camera = Camera.main;
            Vector2 screenpos2 = RectTransformUtility.WorldToScreenPoint(camera, worldpos3);
            Vector2 newvec2;
            bool isCan = RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenpos2, camera, out newvec2);
            if (isCan) return newvec2;
            else
            {
                MyLog.Info('[WorldPosToRtLocalPos]定位失败');
                return Vector2.zero;
            }
        }

        // RenderMode = Screen Space - Camera
        public static string Screenshot(Camera camera, RectTransform rectTransform)
        {
            if (camera == null || rectTransform == null)
            {
                MyLog.Error('Camera or rectTransform is null');
                return null;
            }

            var path = Application.persistentDataPath + '/Scrshot';

            if (!MyPlatformUtils.ExistsFileOrDir(path)) MyPlatformUtils.CreateDirectory(path);
            Rect rt = rectTransform.rect;

            RenderTexture rtrender = new RenderTexture(Screen.width, Screen.height, 0);
            Texture2D screenShot = new Texture2D((int)rt.width, (int)rt.height, TextureFormat.RGB24, false);

            camera.targetTexture = rtrender;
            camera.Render();
            RenderTexture.active = rtrender;

            Vector2 scrpos2 = RectTransformUtility.WorldToScreenPoint(camera, rectTransform.position);
            scrpos2.x += rectTransform.pivot.x * rt.width * -1;
            scrpos2.y += rectTransform.pivot.y * rt.height * -1;

            float y = Screen.height - scrpos2.y - rt.height;
            MyLog.Info($'[Screenshot] Pos x:{scrpos2.x},y:{y}'); // 左上角原点

            screenShot.ReadPixels(new Rect(scrpos2.x, y, rt.width, rt.height), 0, 0);
            screenShot.Apply();

            camera.targetTexture = null;
            RenderTexture.active = null;
            GameObject.DestroyImmediate(rtrender);

            byte[] bytes = screenShot.EncodeToJPG();

            String newjpg = path + '/scrshot_' + DateTime.Now.ToString('yyyy_MM_dd_HH_mm_ss') + '_temp.jpg';
            MyPlatformUtils.WriteFile(newjpg, bytes);
            MyLog.Info($'[Screenshot] path:{newjpg}');
            return newjpg;
        }
    }
```

&lt;/details&gt;


&lt;details&gt;
&lt;summary&gt;贝塞尔曲线&lt;/summary&gt;

```cs
        // 贝塞尔曲线2阶  3个定位点
        public static Vector3[] GetBezierCurve2(Vector3 start, Vector3 center, Vector3 end, int count = 21)
        {
            Vector3[] newpos = new Vector3[count];
            var maxidx = count - 1;
            for (int i = 0; i &lt;= maxidx; i++)
            {
                var t = i * 1.0f / maxidx;
                Vector3 aa = start + (center - start) * t;
                Vector3 bb = center + (end - center) * t;
                newpos[i] = aa + (bb - aa) * t;
            }

            return newpos;
        }

        // 贝塞尔曲线3阶 4个定位点
        public static Vector3[] GetBezierCurve3(Vector3 start, Vector3 center, Vector3 center2, Vector3 end, int count = 21)
        {
            Vector3[] newpos = new Vector3[count];
            var maxidx = count - 1;
            for (int i = 0; i &lt;= maxidx; i++)
            {
                var t = i * 1.0f / maxidx;
                Vector3 aa = start + (center - start) * t;
                Vector3 bb = center + (center2 - center) * t;
                Vector3 cc = center2 + (end - center2) * t;

                Vector3 aaa = aa + (bb - aa) * t;
                Vector3 bbb = bb + (cc - bb) * t;
                newpos[i] = aaa + (bbb - aaa) * t;
            }

            return newpos;
        }
```


&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;适应字符串&lt;/summary&gt;

```cs
using System.Collections.Generic;
using UnityEngine;
using System.Text;
using UnityEngine.UI;
using System;

public class BMTextFit : MonoBehaviour
{
    public enum TextCompProp
    {
        TextLegacy,
        TMP_UI,
        TMP_3D
    }


    [SerializeField] private TextCompProp m_textCompProp;


    
    // 字符换字节宽度限制
    private void FitText1()
    {
        var TComp = GetComponent&lt;Text&gt;();
        var origStr = TComp.text;
        var endIndex = 20;
        
        if (String.IsNullOrEmpty(origStr)) return;
        
        int bytesCount = Encoding.UTF8.GetByteCount(origStr);
        if (bytesCount &gt; endIndex)
        {
            int readyLength = 0;
            float readyWidth = 0;
            for (int i = 0; i &lt; origStr.Length; i++)
            {
                // 中日韩 0x4E00-0x9FFF 字 3字节
                // 标点符号如下范围
                // 0x3000-0x303F 0xFF00-0xFFEF 0xFE10-0xFE1F 0xFE30-0xFE4F 3字节
                // 0x00B7, 0x2014, 0x2026, 0x2018, 0x2019, 0x201C, 0x201D 1字节
                readyLength += Encoding.UTF8.GetByteCount(new [] { origStr[i] });
                if (readyLength == endIndex)
                {
                    origStr = origStr.Substring(0, i + 1) + '...';
                    break;
                }
                else if (readyLength &gt; endIndex)
                {
                    origStr = origStr.Substring(0, i) + '...';
                    break;
                }
            }
        }

        TComp.text = origStr;
    }


    
    // 字符串字节渲染宽度限制
    private void FitText2()
    {
        var TComp = GetComponent&lt;Text&gt;();
        TextGenerator textGenerator = TComp.cachedTextGenerator;
        List&lt;UICharInfo&gt; list_ui_char = new List&lt;UICharInfo&gt;();
        textGenerator.GetCharacters(list_ui_char);
        
        var origStr = TComp.text;
        var maxWidth = 300;
        
        if (String.IsNullOrEmpty(origStr)) return;
        
        float readyWidth = 0;
        for (int i = 0; i &lt; origStr.Length; i++)
        {
            readyWidth += list_ui_char[i].charWidth;
            if (maxWidth == readyWidth)
            {
                origStr = origStr.Substring(0, i + 1) + '...';
                break;
            }
            else if(readyWidth &gt; maxWidth)
            {
                origStr = origStr.Substring(0, i) + '...';
                break;
            }
        }
        
        TComp.text = origStr;
    }
    
    
}




```


&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;屏幕场景偏移&lt;/summary&gt;

```cs
    // 3D场景中 单指滑动屏幕屏幕映射到世界平面的位移增量（世界）
    // 屏幕上的两个点 转换摄像机 平面（点，法线）
    private static Plane s_plane;
    private static Vector3 s_plane_delta;

    public static Vector3 GetDeltaForPlane(Vector2 screen_start,Vector2 screen_end,Vector3 pos_world,Vector3 normal,Camera camera = null)
    {
        if(!camera) camera = Camera.main;

        Ray ray_a = camera.ScreenPointToRay(screen_start);
        Ray ray_b = camera.ScreenPointToRay(screen_end);
        s_plane.SetNormalAndPosition(normal, pos_world);

        float a_distance;
        float b_distance;
        bool a_is = s_plane.Raycast(ray_a, out a_distance);
        bool b_is = s_plane.Raycast(ray_b, out b_distance);

        s_plane_delta.Set(0,0,0);
        if (a_is &amp;&amp; b_is)
        {
            Vector3 pos_a = ray_a.GetPoint(a_distance);
            Vector3 pos_b = ray_b.GetPoint(b_distance);
            s_plane_delta.x = pos_b.x - pos_a.x;
            s_plane_delta.y = pos_b.y - pos_a.y;
            s_plane_delta.z = pos_b.z - pos_a.z;
        }

        return s_plane_delta;
    }
```


&lt;/details&gt;。</description><guid isPermaLink="true">https://ogazen.github.io/post/UI-sao-guang-%E3%80%81-hui-hua-%E3%80%81-jie-ping-%E3%80%81-shi-ying-zi-fu-chuan-%E3%80%81-bei-sai-er-qu-xian-%E3%80%81-ping-mu-chang-jing-pian-yi.html</guid><pubDate>Mon, 17 Nov 2025 09:30:50 +0000</pubDate></item><item><title>高斯模糊</title><link>https://ogazen.github.io/post/gao-si-mo-hu.html</link><description>&gt; ###### 降采样
&gt; 
&gt; 降采样（Downsample）也称下采样（Subsample），按字面意思理解即是降低采样频率。</description><guid isPermaLink="true">https://ogazen.github.io/post/gao-si-mo-hu.html</guid><pubDate>Thu, 13 Nov 2025 06:11:48 +0000</pubDate></item><item><title>URP描边效果</title><link>https://ogazen.github.io/post/URP-miao-bian-xiao-guo.html</link><description>##### 法线外扩/视口夹角

&lt;details&gt;
    &lt;summary&gt;Outline3DOutExternal&lt;/summary&gt;

```hlsl
Shader 'URP/Outline3DOutExternal'
{
    Properties
    {
        _MainTex ('Texture', 2D) = 'white' {}
        _OutlineColor ('Color',Color) = (1,1,1,1)
        _OutlineWidth ('Outline Width',Range(0,0.1)) = 0.1
        _OutlinePowerIn ('Outline PowerIn',Range(0.01,10)) = 1
    }
    SubShader
    {
  


        Pass
        {
            Name 'Outline3D_Inside'
  
            Tags
            {
                'RenderType'='Opaque'
                'Queue'='Transparent'
                'RenderPipeline'='UniversalPipeline'
                'LightMode'='UniversalForward'
            }
            LOD 100
            Blend SrcAlpha OneMinusSrcAlpha

            HLSLPROGRAM
  
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            #pragma vertex vert;
            #pragma fragment frag;
  
            TEXTURE2D_X(_MainTex);
            SAMPLER(sampler_linear_clamp_MainTex);

            CBUFFER_START(UnityPerMaterial)
                half4 _OutlineColor;
                half _OutlinePowerIn;
            CBUFFER_END
  
            struct Varyings
            {
                half4 position : SV_POSITION;
                half2 uv : TEXCOORD0;
                half3 normal_world : TEXCOORD1;
                half3 position_world : TEXCOORD2;
            };


            Varyings vert(half2 uv : TEXCOORD0,half4 position : POSITION,half4 normal : NORMAL)
            {
                Varyings OUT;
                OUT.position_world = mul(GetObjectToWorldMatrix(),position);
                OUT.normal_world = TransformObjectToWorldNormal(normal);
                OUT.position = TransformObjectToHClip(position);
                OUT.uv = uv;
                return OUT;
            }


            half4 frag(Varyings IN) : SV_Target
            {
                half3 direction_view = normalize(GetCameraPositionWS() - (IN.position_world));
                half v = dot(direction_view,IN.normal_world);
                v = 1 - saturate(v);
                v = pow(v,_OutlinePowerIn);
  
                half4 col = SAMPLE_TEXTURE2D_X(_MainTex,sampler_linear_clamp_MainTex,IN.uv);
                return lerp(col,_OutlineColor,v);
            }
  
            ENDHLSL
        }
  

        Pass
        {
            Name 'Outline3D_Swell'
  
            Tags
            {
                'RenderType'='Opaque'
                'Queue'='Transparent'
                'RenderPipeline'='UniversalPipeline'
                'LightMode'='SRPDefaultUnlit'
            }
            LOD 100
            Blend SrcAlpha OneMinusSrcAlpha
            Cull Front

            HLSLPROGRAM
  
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            #pragma vertex vert;
            #pragma fragment frag;


            TEXTURE2D_X(_MainTex);
            SAMPLER(sampler_linear_clamp_MainTex);

            CBUFFER_START(UnityPerMaterial)
                half4 _OutlineColor;
                half _OutlineWidth;
            CBUFFER_END
  
            struct Varyings
            {
                half4 position : SV_POSITION;
                half2 uv : TEXCOORD0;
            };


            Varyings vert(half2 uv : TEXCOORD0,half4 position : POSITION,half4 normal : NORMAL)
            {
                Varyings OUT;
                position.xyz += normal * _OutlineWidth;
                OUT.position = TransformObjectToHClip(position);
                OUT.uv = uv;
                return OUT;
            }


            half4 frag(Varyings IN) : SV_Target
            {
                return _OutlineColor;
            }
  
            ENDHLSL
        }
    }

    Fallback 'Hidden/Universal Render Pipeline/FallbackError'
}
```

&lt;/details&gt;

##### UI描边(配合C#)

&lt;details&gt;
	&lt;summary&gt;OutlineUI&lt;/summary&gt;

```hlsl
Shader 'URP/OutlineUI'
{
    Properties
    {
        [PerRendererData]_MainTex ('Main Texture', 2D) = 'white' { }
        [HideInInspector]_Color ('Tint', Color) = (1, 1, 1, 1)

        [HideInInspector]_StencilComp ('Stencil Comparison', Float) = 8
        [HideInInspector]_Stencil ('Stencil ID', Float) = 0
        [HideInInspector]_StencilOp ('Stencil Operation', Float) = 0
        [HideInInspector]_StencilWriteMask ('Stencil Write Mask', Float) = 255
        [HideInInspector]_StencilReadMask ('Stencil Read Mask', Float) = 255

        [HideInInspector]_ColorMask ('Color Mask', Float) = 15

        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip ('Use Alpha Clip', Float) = 0
        _AlphaClipThreshold ('Alpha Clip Threshold',Range(0,1)) = 0.001
        // 注意：Softness属性这里定义只是为了Material Inspector显示，
        // 实际值将由RectMask2D组件通过MaterialPropertyBlock动态覆盖
        _Softness('Softness', Vector) = (0, 0, 0, 0)
    }

    SubShader
    {
        Tags
        {
            'Queue' = 'Transparent'
            'IgnoreProjector' = 'True'
            'RenderType' = 'Transparent'
            'PreviewType' = 'Plane'
            'CanUseSpriteAtlas' = 'True'
            'RenderPipeline' = 'UniversalPipeline'
        }
  

        Pass
        {
            Name 'UIOutlineEx'
  
            Stencil
            {
                Ref [_Stencil]
                Comp [_StencilComp]
                Pass [_StencilOp]
                ReadMask [_StencilReadMask]
                WriteMask [_StencilWriteMask]
            }
  
            Cull Off
            Lighting Off
            ZWrite Off
            ZTest [unity_GUIZTestMode]
            Blend SrcAlpha OneMinusSrcAlpha
            ColorMask [_ColorMask]

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag


            #pragma multi_compile_local _ UNITY_UI_CLIP_RECT
            #pragma multi_compile_local _ UNITY_UI_ALPHACLIP
  
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            half4 _ClipRect;


            CBUFFER_START(UnityPerMaterial)
            half4 _Color;
            float4 _MainTex_TexelSize;
            half4 _Softness;
            half _AlphaClipThreshold;
            CBUFFER_END

            half4 _TextureSampleAdd;

            struct appdata
            {
                float4 vertex : POSITION;
                float4 texcoord : TEXCOORD0;
                float4 uv1 : TEXCOORD1;
                float4 uv2 : TEXCOORD2;
                half4 color : COLOR;
            };


            struct v2f
            {
                float4 vertex : SV_POSITION;
                float4 texcoord : TEXCOORD0;
                float4 uv1 : TEXCOORD1;
                float4 uv2 : TEXCOORD2;
                half4 color : COLOR;

                half4 objPosition : TEXCOORD3;
            };

            v2f vert(appdata IN)
            {
                v2f o;
  
                o.vertex = TransformObjectToHClip(IN.vertex.xyz);
                o.texcoord = IN.texcoord;
                o.color = IN.color * _Color;
                o.uv1 = IN.uv1;
                o.uv2 = IN.uv2;

                o.objPosition = IN.vertex;
                return o;
            }

            half IsInRect(float2 pPos, float2 pClipRectMin, float2 pClipRectMax)
            {
                pPos = step(pClipRectMin, pPos) * step(pPos, pClipRectMax);
                return pPos.x * pPos.y;
            }

            half SampleAlpha(int pIndex, v2f IN)
            {
                const half sinArray[12] =
                {
                    0, 0.5, 0.866, 1, 0.866, 0.5, 0, -0.5, -0.866, -1, -0.866, -0.5
                };
                const half cosArray[12] =
                {
                    1, 0.866, 0.5, 0, -0.5, -0.866, -1, -0.866, -0.5, 0, 0.5, 0.866
                };
                float2 pos = IN.texcoord.xy + _MainTex_TexelSize.xy * float2(cosArray[pIndex], sinArray[pIndex]) * IN.texcoord.z;
                half pos_uv_col_a = (SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, pos) + _TextureSampleAdd).w;
                return IsInRect(pos, IN.uv1.xy, IN.uv1.zw) * pos_uv_col_a * IN.uv2.w;
            }
  
            half4 frag(v2f IN) : SV_Target
            {
                half4 color = (SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.texcoord.xy) + _TextureSampleAdd) * IN.color;

  
                if (all(IN.texcoord.z))
                {
                    half sign_a = IsInRect(IN.texcoord.xy, IN.uv1.xy, IN.uv1.zw);
                    color.a *= sign_a;
                    half4 val = half4(IN.uv2.rgb, 0);

                    val.w += SampleAlpha(0, IN);
                    val.w += SampleAlpha(1, IN);
                    val.w += SampleAlpha(2, IN);
                    val.w += SampleAlpha(3, IN);
                    val.w += SampleAlpha(4, IN);
                    val.w += SampleAlpha(5, IN);
                    val.w += SampleAlpha(6, IN);
                    val.w += SampleAlpha(7, IN);
                    val.w += SampleAlpha(8, IN);
                    val.w += SampleAlpha(9, IN);
                    val.w += SampleAlpha(10, IN);
                    val.w += SampleAlpha(11, IN);
                    val.w = saturate(val.w);

                    val.w *= IN.texcoord.w;
                    color = lerp(val, color, color.a) * val.w + color * (1 - val.w);
                }


               // 2. --- 核心：应用自定义的RectMask2D裁剪（带软边缘）---
                #if UNITY_UI_CLIP_RECT
                // 2.1 计算片元到裁剪矩形四条边的距离
                half2 minDist = (IN.objPosition.xy - _ClipRect.xy);
                half2 maxDist = (_ClipRect.zw - IN.objPosition.xy);
                half2 edgeDistance = min(minDist, maxDist); // 对于矩形内的点，这个值是正的

                // 2.2 计算软边缘因子
                // saturate(x / softness) ：
                // - 当 x &gt; softness：结果 &gt;= 1，完全保留
                // - 当 0 &lt; x &lt; softness：结果在 0 到 1 之间，平滑过渡
                // - 当 x &lt; 0：结果为 0，完全裁剪
                // 使用max(softness, 0.001)避免除以零
                half2 softnessFactor = saturate(edgeDistance / max(_Softness.xy, 0.001));

                // 2.3 综合两个方向的因子（取最小值，这样任何一个方向出界都会导致裁剪）
                half finalAlphaFactor = softnessFactor.x * softnessFactor.y;

                // 2.4 将裁剪因子应用到最终颜色的Alpha通道
                color.a *= finalAlphaFactor;
                #endif

  
                #if UNITY_UI_ALPHACLIP
                    clip(color.a - _AlphaClipThreshold);
                #endif


                return color;
            }

  
            ENDHLSL
        }
    }
}
```

&lt;/details&gt;

&lt;details&gt;
	&lt;summary&gt;UIOutlineEx&lt;/summary&gt;

```cs
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

/// &lt;summary&gt;
/// UGUI描边
/// &lt;/summary&gt;
public class UIOutlineEx : BaseMeshEffect
{
    private static List&lt;UIVertex&gt; m_VetexList = new List&lt;UIVertex&gt;();

    // 公开变量
    public Color OutlineColor = Color.black;
    [Range(0.01f, 6)] public float OutlineWidth = 1;
    [SerializeField] private Material m_outlineMaterial;
    [SerializeField] private bool m_DrawOutline;

    // 私有变量
    private float m_uivertex_alpha_max = 0;
    private CanvasGroup[] m_canvasGroups;
    private float m_canvasGroups_alphamul = 1;


    public void SetDrawOutline(bool draw)
    {
        m_DrawOutline = draw;
    }
  
  
  
    protected override void Awake()
    {
        base.Awake();

        if (base.graphic)
        {
            if (base.graphic.canvas)
            {
                var v1 = base.graphic.canvas.additionalShaderChannels;
                var v2 = AdditionalCanvasShaderChannels.TexCoord1;
                if ((v1 &amp; v2) != v2)
                {
                    base.graphic.canvas.additionalShaderChannels |= v2;
                }
                v2 = AdditionalCanvasShaderChannels.TexCoord2;
                if ((v1 &amp; v2) != v2)
                {
                    base.graphic.canvas.additionalShaderChannels |= v2;
                }
            }
            this._Refresh();
        }
    }

    protected override void OnDestroy()
    {
        base.graphic.material = null;
    }


    protected override void OnEnable()
    {
        base.graphic.material = m_outlineMaterial;
        this._Refresh();
    }

    protected override void OnDisable()
    {
        base.graphic.material = null;
        this._Refresh();
    }

    protected override void Start()
    {
        base.graphic.material = m_outlineMaterial;
    }


    protected override void OnCanvasGroupChanged()
    {
        base.OnCanvasGroupChanged();
        if (m_canvasGroups == null) m_canvasGroups = GetComponentsInParent&lt;CanvasGroup&gt;();

        m_canvasGroups_alphamul = 1;
        for (int i = 0; i &lt; m_canvasGroups.Length; i++)
        {
            m_canvasGroups_alphamul *= m_canvasGroups[i].alpha;
        }
        this._Refresh();
    }
  

    private void _Refresh()
    {
        base.graphic.SetVerticesDirty();
    }


    public override void ModifyMesh(VertexHelper vh)
    {
        if(!m_DrawOutline) return;
  
        vh.GetUIVertexStream(m_VetexList);

        m_uivertex_alpha_max = 0;
        for (int i = 0; i &lt; m_VetexList.Count; i++)
        {
            var v = m_VetexList[i];
            if (v.color.a / 255f &gt; m_uivertex_alpha_max) m_uivertex_alpha_max = v.color.a / 255f;
        }
        m_uivertex_alpha_max *= m_canvasGroups_alphamul;

        this._ProcessVertices();

        vh.Clear();
        vh.AddUIVertexTriangleStream(m_VetexList);
    }


    private void _ProcessVertices()
    {
        for (int i = 0, count = m_VetexList.Count - 3; i &lt;= count; i += 3)
        {
            var v1 = m_VetexList[i];
            var v2 = m_VetexList[i + 1];
            var v3 = m_VetexList[i + 2];
  
  
  
            // 计算原顶点坐标中心点
            //
            var minX = _Min(v1.position.x, v2.position.x, v3.position.x);
            var minY = _Min(v1.position.y, v2.position.y, v3.position.y);
            var maxX = _Max(v1.position.x, v2.position.x, v3.position.x);
            var maxY = _Max(v1.position.y, v2.position.y, v3.position.y);
            var posCenter = new Vector2(minX + maxX, minY + maxY) * 0.5f;
  
  
  
            // 计算原始顶点坐标和UV的方向
            //
            Vector2 triX, triY, uvX, uvY;
            Vector2 pos1 = v1.position;
            Vector2 pos2 = v2.position;
            Vector2 pos3 = v3.position;
            if (Mathf.Abs(Vector2.Dot((pos2 - pos1).normalized, Vector2.right))
                &gt; Mathf.Abs(Vector2.Dot((pos3 - pos2).normalized, Vector2.right)))
            {
                triX = pos2 - pos1;
                triY = pos3 - pos2;
                uvX = v2.uv0 - v1.uv0;
                uvY = v3.uv0 - v2.uv0;
            }
            else
            {
                triX = pos3 - pos2;
                triY = pos2 - pos1;
                uvX = v3.uv0 - v2.uv0;
                uvY = v2.uv0 - v1.uv0;
            }
  
  
  
            // 计算原始UV框
            var uvMin = _Min(v1.uv0, v2.uv0, v3.uv0);
            var uvMax = _Max(v1.uv0, v2.uv0, v3.uv0);

            // 为每个顶点设置新的Position和UV，并传入原始UV框
            v1 = _SetNewPosAndUV(v1, this.OutlineWidth, posCenter, triX, triY, uvX, uvY, uvMin, uvMax);
            v2 = _SetNewPosAndUV(v2, this.OutlineWidth, posCenter, triX, triY, uvX, uvY, uvMin, uvMax);
            v3 = _SetNewPosAndUV(v3, this.OutlineWidth, posCenter, triX, triY, uvX, uvY, uvMin, uvMax);


            // 应用设置后的UIVertex
            //
            m_VetexList[i] = v1;
            m_VetexList[i + 1] = v2;
            m_VetexList[i + 2] = v3;
        }
    }


    private UIVertex _SetNewPosAndUV(
        UIVertex pVertex, float pOutLineWidth,
        Vector2 pPosCenter,
        Vector2 pTriangleX, Vector2 pTriangleY,
        Vector2 pUVX, Vector2 pUVY,
        Vector2 pUVOriginMin, Vector2 pUVOriginMax)
    {
        // Position
        var pos = pVertex.position;
        var posXOffset = pos.x &gt; pPosCenter.x ? pOutLineWidth : -pOutLineWidth;
        var posYOffset = pos.y &gt; pPosCenter.y ? pOutLineWidth : -pOutLineWidth;
        pos.x += posXOffset;
        pos.y += posYOffset;
        pVertex.position = pos;
  
        // UV
        var uv = (Vector2)pVertex.uv0;
        var uv_additional_x = pUVX / pTriangleX.magnitude * posXOffset * (Vector2.Dot(pTriangleX, Vector2.right) &gt; 0 ? 1 : -1);
        var uv_additional_y = pUVY / pTriangleY.magnitude * posYOffset * (Vector2.Dot(pTriangleY, Vector2.up) &gt; 0 ? 1 : -1);
        uv += uv_additional_x;
        uv += uv_additional_y;
        pVertex.uv0 = uv;
  
  
        pVertex.uv0.z = pOutLineWidth; // z：定位为宽度
        pVertex.uv0.w = m_uivertex_alpha_max; // w：所有顶点中最大的透明度值

  
        // uv1 uv2 可用
        pVertex.uv1 = pUVOriginMin;     // uv1：定位为最小最大值数据
        pVertex.uv1.z = pUVOriginMax.x;
        pVertex.uv1.w = pUVOriginMax.y;

        pVertex.uv2 = this.OutlineColor; // uv2：定位为描边颜色

        return pVertex;
    }


    private static float _Min(float pA, float pB, float pC)
    {
        return Mathf.Min(Mathf.Min(pA, pB), pC);
    }


    private static float _Max(float pA, float pB, float pC)
    {
        return Mathf.Max(Mathf.Max(pA, pB), pC);
    }


    private static Vector2 _Min(Vector2 pA, Vector2 pB, Vector2 pC)
    {
        return new Vector2(_Min(pA.x, pB.x, pC.x), _Min(pA.y, pB.y, pC.y));
    }


    private static Vector2 _Max(Vector2 pA, Vector2 pB, Vector2 pC)
    {
        return new Vector2(_Max(pA.x, pB.x, pC.x), _Max(pA.y, pB.y, pC.y));
    }
}
```

&lt;/details&gt;

##### 后处理Feature

&lt;details&gt;
	&lt;summary&gt;URP_Feature_Outline3D&lt;/summary&gt;

```cs
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class URP_Feature_Outline3D : ScriptableRendererFeature
{
    class Outline3DRenderPass : ScriptableRenderPass
    {
        private static readonly List&lt;ShaderTagId&gt; s_shaderTagIds = new List&lt;ShaderTagId&gt;()
        {
            new ShaderTagId('UniversalForward'),
            new ShaderTagId('UniversalForwardOnly'),
            new ShaderTagId('SRPDefaultUnlit')
        };
        private static readonly int s_shaderProperty_outline3d = Shader.PropertyToID('_Outline3D');



        private readonly Material m_outline_material;
        private readonly FilteringSettings m_filteringSettings;
        private readonly MaterialPropertyBlock m_materialPropertyBlock;
        private RTHandle m_outline_rtHandle;


        public Outline3DRenderPass(Material material)
        {
            // Configures where the render pass should be injected.
            renderPassEvent = RenderPassEvent.AfterRenderingPostProcessing;
        
            m_outline_material = material;
            m_filteringSettings = new FilteringSettings(RenderQueueRange.all, renderingLayerMask: 0b10);
            m_materialPropertyBlock = new MaterialPropertyBlock();
        }


        public void Dispose()
        {
            m_outline_rtHandle?.Release();
            m_outline_rtHandle = null;
        
        }





        // This method is called before executing the render pass.
        // It can be used to configure render targets and their clear state. Also to create temporary render target textures.
        // When empty this render pass will render to the active camera render target.
        // You should never call CommandBuffer.SetRenderTarget. Instead call &lt;c&gt;ConfigureTarget&lt;/c&gt; and &lt;c&gt;ConfigureClear&lt;/c&gt;.
        // The render pipeline will ensure target setup and clearing happens in a performant manner.
        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)
        {

            var desc_camera = renderingData.cameraData.cameraTargetDescriptor;
            desc_camera.msaaSamples = 1;
            desc_camera.depthBufferBits = 0;
            desc_camera.colorFormat = RenderTextureFormat.ARGB32;
            RenderingUtils.ReAllocateIfNeeded(ref m_outline_rtHandle, desc_camera, name: '_Outline3D');
        }

        // Here you can implement the rendering logic.
        // Use &lt;c&gt;ScriptableRenderContext&lt;/c&gt; to issue drawing commands or execute command buffers
        // https://docs.unity3d.com/ScriptReference/Rendering.ScriptableRenderContext.html
        // You don't have to call ScriptableRenderContext.submit, the render pipeline will call it at specific points in the pipeline.
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
        {
            var cmd = CommandBufferPool.Get('Outline3D CMD');

            // CMD
            cmd.SetRenderTarget(m_outline_rtHandle);
            cmd.ClearRenderTarget(true, true, Color.clear);


            var draw_settings = CreateDrawingSettings(s_shaderTagIds, ref renderingData, SortingCriteria.None);
            RendererListParams rendererListParams = new RendererListParams(renderingData.cullResults, draw_settings, m_filteringSettings);
            var list_draw = context.CreateRendererList(ref rendererListParams);
            cmd.DrawRendererList(list_draw);
        
        
            // cmd.SetRenderTarget(renderingData.cameraData.renderer.cameraColorTargetHandle);
            // m_materialPropertyBlock.SetTexture(s_shaderProperty_outline3d, m_outline_rtHandle);
            // cmd.DrawProcedural(Matrix4x4.identity, m_outline_material, 0, MeshTopology.Triangles, 3, 1, m_materialPropertyBlock);
            m_outline_material.SetTexture(s_shaderProperty_outline3d, m_outline_rtHandle);
            Blitter.BlitCameraTexture(cmd, m_outline_rtHandle,renderingData.cameraData.renderer.cameraColorTargetHandle,m_outline_material,0);



            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }

        // Cleanup any allocated resources that were created during the execution of this render pass.
        //public override void OnCameraCleanup(CommandBuffer cmd)
        //{
        //}
    }






    [SerializeField] private Material m_OutlineMaterial;
    private Outline3DRenderPass m_Outline3DScriptablePass;

    private bool IsMaterialValid =&gt; m_OutlineMaterial &amp;&amp; m_OutlineMaterial.shader &amp;&amp; m_OutlineMaterial.shader.isSupported;


    /// &lt;inheritdoc/&gt;
    public override void Create()
    {
        if (!IsMaterialValid)
        {
            return;
        }

        m_Outline3DScriptablePass = new Outline3DRenderPass(m_OutlineMaterial);
    }

    // Here you can inject one or multiple render passes in the renderer.
    // This method is called when setting up the renderer once per-camera.
    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
    {
        if (m_Outline3DScriptablePass == null)
        {
            return;
        }


        renderer.EnqueuePass(m_Outline3DScriptablePass);
    }


    protected override void Dispose(bool disposing)
    {
        m_Outline3DScriptablePass?.Dispose();
    }

}
```

&lt;/details&gt;

&lt;details&gt;
	&lt;summary&gt;Outline3D&lt;/summary&gt;

```hlsl
Shader 'URP/Outline3D'
{
    Properties
    {
        _OutlineColor ('Outline Color', Color) = (1, 1, 1, 1)
        _OutlineWidth ('Outline Width', Range(0, 0.01)) = 0.001
    }

    SubShader
    {
        Tags
        {
            'RenderType' = 'Opaque'
            'RenderPipeline' = 'UniversalPipeline'
            'Queue' = 'Geometry'
        }
        LOD 100
        
        ZWrite Off
        Cull Off
        Blend SrcAlpha OneMinusSrcAlpha

        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'
            #include 'Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl'


            struct Attributes
            {
                uint vertex_id : SV_VERTEXID;
            };

            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                half2 uv : TEXCOORD;
                half2 offsets[8] : TEXCOORD1;
            };


            TEXTURE2D_X(_Outline3D);
            SAMPLER(sampler_linear_clamp_Outline3D);

            CBUFFER_START(UnityPerMaterial)
            half4 _OutlineColor;
            float _OutlineWidth;
            CBUFFER_END


            Varyings vert(Attributes IN)
            {
                Varyings Output;
                Output.positionCS = GetFullScreenTriangleVertexPosition(IN.vertex_id);
                Output.uv = GetFullScreenTriangleTexCoord(IN.vertex_id);

                const half ratio_w_h = _ScreenParams.x / _ScreenParams.y;
                const float multipty_num_2 = 0.707; // sprt(2) / 2

                Output.offsets[0] = half2(-1, ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[1] = half2(0, ratio_w_h) * _OutlineWidth;
                Output.offsets[2] = half2(1, ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[3] = half2(-1, 0) * _OutlineWidth;
                
                Output.offsets[4] = half2(1, 0) * _OutlineWidth;
                Output.offsets[5] = half2(-1, -ratio_w_h) * _OutlineWidth * multipty_num_2;
                Output.offsets[6] = half2(0, -ratio_w_h) * _OutlineWidth;
                Output.offsets[7] = half2(1, -ratio_w_h) * _OutlineWidth * multipty_num_2;

                return Output;
            }



            half4 frag(Varyings IN) : SV_Target
            {
                const half kernelX[8] =
                {
                    - 1, 0, 1,
                    - 2, 2,
                    - 1, 0, 1
                };

                const half kernelY[8] =
                {
                    - 1, -2, -1,
                    0, 0,
                    1, 2, 1
                };


                half gx = 0;
                half gy = 0;
                half multiply_num = 0;

                for (int i = 0; i &lt; 8; i++)
                {
                    multiply_num = SAMPLE_TEXTURE2D_X(_Outline3D, sampler_linear_clamp_Outline3D, IN.uv + IN.offsets[i]).a;
                    gx += multiply_num * kernelX[i];
                    gy += multiply_num * kernelY[i];
                }

                const half _a = SAMPLE_TEXTURE2D_X(_Outline3D, sampler_linear_clamp_Outline3D, IN.uv).a;
                half4 col = _OutlineColor;
                col.a = saturate(abs(gx) + abs(gy)) * (1 - _a);

                
                return col;
            }

            ENDHLSL
        }
    }
}
```

&lt;/details&gt;

##### 后处理Feature2

&lt;details&gt;
	&lt;summary&gt;URP_Feature_Outline3D_2&lt;/summary&gt;

```cs
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.RendererUtils;
using UnityEngine.Rendering.Universal;
using UnityEngine.Serialization;

public class URP_Feature_Outline3D_2 : ScriptableRendererFeature
{
    private class Outline3DRenderPass : ScriptableRenderPass
    {
        private static readonly List&lt;ShaderTagId&gt; s_shaderTagIds = new List&lt;ShaderTagId&gt;()
        {
            new ShaderTagId('UniversalForward'),
            new ShaderTagId('UniversalForwardOnly'),
            new ShaderTagId('SRPDefaultUnlit')
        };
        
        
        private readonly Material m_outline_material;
        private readonly Color m_outlineColor = Color.yellow;
        private readonly float m_downSampleScale = 0.5f; 
        private readonly int m_blurIterations = 1; 
        private readonly float m_blurWidth = 1.0f;
        
        
        
        private readonly FilteringSettings m_filteringSettings;
        private readonly MaterialPropertyBlock m_materialPropertyBlock;
        
        private RTHandle m_outline_rtHandle;
        private RTHandle m_temp_downsample_rtHandle;
        private RTHandle m_temp_blurRt;

        public Outline3DRenderPass(Material material,Color outlineColor,float downSampleScale,int blurIterations,float blurWidth)
        {
            // Configures where the render pass should be injected.
            renderPassEvent = RenderPassEvent.AfterRenderingPostProcessing;

            m_outline_material = material;
            m_outlineColor = outlineColor;
            m_downSampleScale = downSampleScale;
            m_blurIterations = blurIterations;
            m_blurWidth = blurWidth;
            
            m_filteringSettings = new FilteringSettings(RenderQueueRange.all, renderingLayerMask: 0b10);
            m_materialPropertyBlock = new MaterialPropertyBlock();
        }


        public void Dispose()
        {
            m_outline_rtHandle?.Release();
            m_outline_rtHandle = null;
            m_temp_blurRt?.Release();
            m_temp_blurRt = null;
            m_temp_downsample_rtHandle?.Release();
            m_temp_downsample_rtHandle = null;
        }




        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)
        {

            var desc_camera = renderingData.cameraData.cameraTargetDescriptor;
            desc_camera.msaaSamples = 1;
            desc_camera.depthBufferBits = 0;
            desc_camera.colorFormat = RenderTextureFormat.ARGB32;
            RenderingUtils.ReAllocateIfNeeded(ref m_outline_rtHandle, desc_camera, name: '_Outline3D');
            
            Vector2 scaleFactor = new Vector2(m_downSampleScale, m_downSampleScale);
            RenderingUtils.ReAllocateIfNeeded(ref m_temp_downsample_rtHandle,scaleFactor,desc_camera ,name: '_TempDownsample',filterMode:FilterMode.Bilinear);
            RenderingUtils.ReAllocateIfNeeded(ref m_temp_blurRt,scaleFactor,desc_camera ,name: '_TempBlur',filterMode:FilterMode.Bilinear);
        }
        
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
        {
            var cameraData = renderingData.cameraData;
            if (cameraData.camera.cameraType != CameraType.Game)
                return;

            if (m_outline_material == null)
                return;
            
            
            
            
            var cmd = CommandBufferPool.Get('Outline3D CMD');

            // CMD
            cmd.SetRenderTarget(m_temp_downsample_rtHandle);
            cmd.ClearRenderTarget(true, true, Color.clear);
            
            cmd.SetRenderTarget(m_temp_blurRt);
            cmd.ClearRenderTarget(true, true, Color.clear);
            
            cmd.SetRenderTarget(m_outline_rtHandle);
            cmd.ClearRenderTarget(true, true, Color.clear);


            var draw_settings = CreateDrawingSettings(s_shaderTagIds, ref renderingData, SortingCriteria.None);
            RendererListParams rendererListParams = new RendererListParams(renderingData.cullResults, draw_settings, m_filteringSettings);
            var list_draw = context.CreateRendererList(ref rendererListParams);
            cmd.DrawRendererList(list_draw);

            
            
            
            // Pass0
            m_outline_material.SetColor('_OutlineColor', m_outlineColor);
            Blitter.BlitCameraTexture(cmd, m_outline_rtHandle,m_outline_rtHandle,m_outline_material,0);
            m_outline_material.SetTexture('_OutlineColorTex', m_outline_rtHandle);

            
            
            // Pass1
            m_outline_material.SetFloat('_BlurWidth', m_blurWidth);
            for (int i = 0; i &lt; m_blurIterations; ++i)
            {
                if (i == 0)
                {
                    Blitter.BlitCameraTexture(cmd, m_outline_rtHandle,m_temp_downsample_rtHandle,m_outline_material,1);
                    Blitter.BlitCameraTexture(cmd, m_temp_downsample_rtHandle,m_temp_blurRt,m_outline_material,1);
                }
                else
                {
                    Blitter.BlitCameraTexture(cmd, m_temp_blurRt,m_temp_downsample_rtHandle,m_outline_material,1);
                    Blitter.BlitCameraTexture(cmd, m_temp_downsample_rtHandle,m_temp_blurRt,m_outline_material,1);
                }
            }
            
            

            // Pass2
            m_outline_material.SetTexture('_BlurTex', m_temp_blurRt);
            
            
            RTHandle targetRT = cameraData.renderer.cameraColorTargetHandle;
            Blitter.BlitCameraTexture(cmd, targetRT,targetRT,m_outline_material,2);
            
            
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }

        
        public override void OnCameraCleanup(CommandBuffer cmd)
        {
            
        }
    }






    [SerializeField] private Material m_OutlineMaterial;
    public Color m_outlineColor = Color.yellow;

    [Range(0.1f, 1)]
    public float m_downSampleScale = 0.5f;                 // 降采样比例
    [Range(0, 4)]
    public int m_blurIterations = 1;                  // 均值糊迭代次数
    [FormerlySerializedAs('m_blurRadius')] [Range (0.2f, 10.0f)]
    public float m_blurWidth = 1.0f;
    
    private bool IsMaterialValid =&gt; m_OutlineMaterial &amp;&amp; m_OutlineMaterial.shader &amp;&amp; m_OutlineMaterial.shader.isSupported;

    
    
    
    private Outline3DRenderPass m_Outline3DScriptablePass;
    

    /// &lt;inheritdoc/&gt;
    public override void Create()
    {
        if (!IsMaterialValid)
        {
            return;
        }

        m_Outline3DScriptablePass = new Outline3DRenderPass(m_OutlineMaterial,m_outlineColor,m_downSampleScale,m_blurIterations,m_blurWidth);
    }
    
    
    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
    {
        if (m_Outline3DScriptablePass == null)
        {
            return;
        }

        if (renderingData.cameraData.cameraType == CameraType.Game)
        {
            renderer.EnqueuePass(m_Outline3DScriptablePass);
        }
    }


    protected override void Dispose(bool disposing)
    {
        m_Outline3DScriptablePass?.Dispose();
    }

}
```

&lt;/details&gt;

&lt;details&gt;
	&lt;summary&gt;PostEffectOutline3D&lt;/summary&gt;

```hlsl
Shader 'URP/PostEffectOutline3D'
{
    Properties
    {
    	[PerRendererData]_OutlineColor ('Outline Color',Color) = (1,1,1,1)
    	[PerRendererData]_BlurRadius('Blur Width',Float) = 1
    }
    SubShader
    {
        Tags
        {
            'RenderType'='Opaque'
            'RenderPipeline'='UniversalPipeline'
            'IgnoreProjector'='true'
        	'Queue' = 'Geometry'
        }
        LOD 100
		Cull Off 
		ZWrite Off
	    Blend SrcAlpha OneMinusSrcAlpha
        
        HLSLINCLUDE
        
        #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'
        #include 'Packages/com.unity.render-pipelines.core/Runtime/Utilities/Blit.hlsl'
        
        TEXTURE2D_X(_CameraOpaqueTexture);
        TEXTURE2D_X(_OutlineColorTex);
        TEXTURE2D_X(_BlurTex);
        SAMPLER(sampler_linear_clamp_CameraOpaqueTexture);

        half4 _BlitTexture_TexelSize;
        CBUFFER_START(UnityPerMaterial)
            half4 _OutlineColor;
		    float _BlurWidth;
        CBUFFER_END


        struct appdata_img
        {
	        half4 vertex : POSITION;
        	half2 texcoord : TEXCOORD0;
        };

        
        struct v2f
		{
			float4 pos : SV_POSITION;
			half2 uv_ : TEXCOORD0;
			half4 uv1 : TEXCOORD3;
			half4 uv2 : TEXCOORD4;
			half4 uv3 : TEXCOORD5;
			half4 uv4 : TEXCOORD6;
		};
        
        

        // 均值模糊
        // ---------------------------【顶点着色器】---------------------------
        v2f vert_average(appdata_img v,uint vid : SV_VertexID)  
        {  
            v2f o;  
            o.pos = GetFullScreenTriangleVertexPosition(vid); //TransformObjectToHClip(v.vertex);  
            //uv坐标  
            o.uv_ = GetFullScreenTriangleTexCoord(vid); //v.texcoord.xy;  
            //计算周围的8个uv坐标
            o.uv1.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(1, 0) * _BlurWidth;  
            o.uv1.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(-1, 0) * _BlurWidth;
            
            o.uv2.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(0, 1) * _BlurWidth;
            o.uv2.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(0, -1) * _BlurWidth;
            
            o.uv3.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(1, 1) * _BlurWidth;
            o.uv3.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(-1, 1) * _BlurWidth;
            
            o.uv4.xy = o.uv_ + _BlitTexture_TexelSize.xy * float2(1, -1) * _BlurWidth;
            o.uv4.zw = o.uv_ + _BlitTexture_TexelSize.xy * float2(-1, -1) * _BlurWidth;
            return o;  
        }  
        
        // ---------------------------【片元着色器】---------------------------
        half4 frag_average(v2f i) : SV_Target  
        {  
            half4 color = half4(0,0,0,0);  
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv1.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv1.zw);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv2.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv2.zw);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv3.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv3.zw);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv4.xy);
            color += SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv4.zw);
            // 取平均值
            return color / 9;
        }
        
        
        ENDHLSL
        
        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert
			#pragma fragment frag
            
            v2f vert (appdata_img v,uint vid : SV_VertexID)
            {
                v2f o;
				o.uv_ = GetFullScreenTriangleTexCoord(vid); //v.texcoord;
        		o.pos = GetFullScreenTriangleVertexPosition(vid); //TransformObjectToHClip(v.vertex);
                return o;
            }

            half4 frag (v2f i) : SV_Target
            {
            	half4 col = SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
            	clip(col.r - 0.1f);
            	return _OutlineColor;
            }
            
           ENDHLSL
        }


        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert_average
			#pragma fragment frag_average
            
            ENDHLSL
        }




        Pass
        {
            HLSLPROGRAM

            #pragma vertex vert;
            #pragma fragment frag;

            v2f vert(appdata_img v,uint vid : SV_VertexID)
            {
                v2f o;
                o.pos = GetFullScreenTriangleVertexPosition(vid); //TransformObjectToHClip(v.vertex);
                o.uv_ = GetFullScreenTriangleTexCoord(vid); //v.texcoord;
                return o;
            }
            

			half4 frag(v2f i) : SV_Target
			{
				half4 scene = SAMPLE_TEXTURE2D_X(_BlitTexture,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
				half4 blur = SAMPLE_TEXTURE2D_X(_BlurTex, sampler_linear_clamp_CameraOpaqueTexture,i.uv_);
				half4 outlieColor = SAMPLE_TEXTURE2D_X(_OutlineColorTex,sampler_linear_clamp_CameraOpaqueTexture, i.uv_);
				half4 o = outlieColor - blur;

				half sign = step(0.01h,o.a);
				half4 colMix = lerp(scene,_OutlineColor,o.a);
				return scene * (1-sign) + sign * colMix;
			}
            
            ENDHLSL
        }
        

    }
}

```



&lt;/details&gt;
。</description><guid isPermaLink="true">https://ogazen.github.io/post/URP-miao-bian-xiao-guo.html</guid><pubDate>Wed, 12 Nov 2025 02:52:48 +0000</pubDate></item><item><title>手自一体6AT变速箱</title><link>https://ogazen.github.io/post/shou-zi-yi-ti-6AT-bian-su-xiang.html</link><description>#### 使用技巧1

&gt; [!NOTE]
&gt; D : 前进档-最常用
&gt; S : 运动档(Sport)-较D档延迟升档
&gt; P : 驻车档
&gt; R : 倒车档
&gt; N : 空挡
&gt; M : 手动档-上波升档下拨降档

##### S档

起步时用s档不合适！对速度提升是适得其反，原因在于6档前进的车，1、2档齿在1、2档停留时间过长速度是上不去的，而在车身没有大负重的情况下，反而浪费了速度提升。</description><guid isPermaLink="true">https://ogazen.github.io/post/shou-zi-yi-ti-6AT-bian-su-xiang.html</guid><pubDate>Tue, 11 Nov 2025 03:40:50 +0000</pubDate></item><item><title>关键字 变体</title><link>https://ogazen.github.io/post/guan-jian-zi-%20-bian-ti.html</link><description>#### 最常用引入(URP)

* Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl
* Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl
* Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderVariablesFunctions.hlsl
* Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl
* Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl
* Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl
* Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl
* Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareOpaqueTextue.hlsl
* Packages/com.unity.render-pipelines.core/Runtime/Utilities/Blit.hlsl

#### 着色器变体/剥离(Build-In)

[使用快捷键创建关键字集 ](https://docs.unity3d.com/2022.3/Documentation/Manual/SL-MultipleProgramVariants-shortcuts.html)

| Shortcut                               | Shader keywords Unity adds                                                                                                                                                                                                          | Unity adds a variant with all the keywords off | Shader pass that uses the variants                                                                                                                                              |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `multi_compile_fog`                | `FOG_LINEAR`, `FOG_EXP`, `FOG_EXP2`                                                                                                                                                                                     | Yes                                            | Fog                                                                                                                                                                             |
| `multi_compile_fwdadd`             | `POINT` `DIRECTIONAL` `SPOT` `POINT_COOKIE` `DIRECTIONAL_COOKIE`                                                                                                                                                | No                                             | PassType.ForwardAdd                                                             |
| `multi_compile_fwdadd_fullshadows` | `POINT`, `DIRECTIONAL`, `SPOT`, `POINT_COOKIE`, `DIRECTIONAL_COOKIE`, `SHADOWS_DEPTH SHADOWS_SCREEN` `SHADOWS_CUBE SHADOWS_SOFT SHADOWS_SHADOWMASK`, `LIGHTMAP_SHADOW_MIXING`                       | No                                             | PassType.ForwardAdd|
| `multi_compile_fwdbase`            | `DIRECTIONAL`, `LIGHTMAP_ON`, `DIRLIGHTMAP_COMBINED`, `DYNAMICLIGHTMAP_ON`, `SHADOWS_SCREEN`, `SHADOWS_SHADOWMASK`, `LIGHTMAP_SHADOW_MIXING`, `LIGHTPROBE_SH`                                       | No                                             | PassType.ForwardBase                                                              |
| `multi_compile_fwdbasealpha`       | `DIRECTIONAL`, `LIGHTMAP_ON`, `DIRLIGHTMAP_COMBINED`, `DYNAMICLIGHTMAP_ON`, `LIGHTMAP_SHADOW_MIXING`, `VERTEXLIGHT_ON`, `LIGHTPROBE_SH`                                                                 | No                                             | PassType.ForwardBase                                                        |
| `multi_compile_instancing`         | `INSTANCING_ON`. Also adds `PROCEDURAL_ON` if your project uses procedural instancing.                                                                                                                                      | Yes                                            | Instancing                                                                                                                                                                      |
| `multi_compile_lightpass`          | `POINT`, `DIRECTIONAL`, `SPOT`, `POINT_COOKIE`, `DIRECTIONAL_COOKIE`, `SHADOWS_DEPTH`, `SHADOWS_SCREEN`, `SHADOWS_CUBE`, `SHADOWS_SOFT`, `SHADOWS_SHADOWMASK`, `LIGHTMAP_SHADOW_MIXING` | No                                             | All passes that draw real-time light and shadows, except **Light Probes**.                                                                                               |
| `multi_compile_particles`          | `SOFTPARTICLES_ON`                                                                                                                                                                                                              | Yes                                            | Particle System passes.                                                                                                                                                       |
| `multi_compile_prepassfinal`       | `LIGHTMAP_ON`, `DIRLIGHTMAP_COMBINED`, `DYNAMICLIGHTMAP_ON`, `UNITY_HDR_ON`, `SHADOWS_SHADOWMASK`, `LIGHTPROBE_SH`                                                                                          | Yes                                            | PassType.Deferredl                                         |
| `multi_compile_shadowcaster`       | `SHADOWS_DEPTH`, `SHADOWS_CUBE`                                                                                                                                                                                             | No                                             | PassType.ShadowCaster                                                      |
| `multi_compile_shadowcollector`    | `SHADOWS_SPLIT_SPHERES`, `SHADOWS_SINGLE_CASCADE`                                                                                                                                                                           | Yes                                            | Screen-space shadows.                                                                                                                                                           |

##### 移除变体

```hlsl
#pragma multi_compile_fwdadd
#pragma skip_variants POINT POINT_COOKIE
```

##### 指明着色器关键字阶段

[着色器变体剥离 ](https://docs.unity3d.com/2022.3/Documentation/Manual/shader-variant-stripping.html)

&gt; 例：#pragma multi_compile_fragment 仅作用于fragment计算
&gt; 类似的还有
&gt; `_vertex`
&gt; `_fragment`
&gt; `_hull`
&gt; `_domain`
&gt; `_geometry`
&gt; `_raytracing`

#### 着色器变体/剥离(URP)

[Shader Stripping | Universal RP | 14.0.12](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/shader-stripping.html)

| **Feature**               | **How to disable the feature**                                                                                                                                                             | **Shader keywords this turns off**                                                                                                                                            | **Rendering Path** |
| --------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- |
| Accurate G-buffer normals       | Disable **Accurate G-buffer normals** in the URP Asset. This has no effect on platforms that use the Vulkan graphics API.                                                                  | `_GBUFFER_NORMALS_OCT`                                                                                                                                                          | Deferred                 |
| Additional lights               | In the ​**URP Asset**​, in the ​**Lighting section**​, disable ​**Additional Lights**​.                                                                                  | `_ADDITIONAL_LIGHTS`, `_ADDITIONAL_LIGHTS_VERTEX`                                                                                                                           | Forward                  |
| Ambient occlusion               | Remove the Ambient Occlusion Renderer Feature in all Renderers that URP Assets use. | `_SCREEN_SPACE_OCCLUSION`                                                                                                                                                       | Forward and Deferred     |
| Decals                          | Remove the Decals Renderer Feature in all Renderers that URP Assets use.          | `_DBUFFER_MRT1`, `_DBUFFER_MRT2`, `_DBUFFER_MRT3`, `_DECAL_NORMAL_BLEND_LOW`, `_DECAL_NORMAL_BLEND_MEDIUM`, `_DECAL_NORMAL_BLEND_HIGH`, `_DECAL_LAYERS` | Forward and Deferred     |
| Fast sRGB to linear conversion  | In the ​**URP Asset**​, in the **Post-processing** section, disable ​**Fast sRGB/Linear conversions**​.                                                                    | `_USE_FAST_SRGB_LINEAR_CONVERSION`                                                                                                                                              | Forward and Deferred     |
| Holes in terrain                | In the ​**URP Asset**​, in the **Rendering** section, disable ​**Terrain Holes**​.                                                                                         | `_ALPHATEST_ON`                                                                                                                                                                 | Forward                  |
| Light cookies                   | Remove Cookie textures from all the lights in your project.                                                                                         | `_LIGHT_COOKIES`                                                                                                                                                                | Forward and Deferred     |
| Rendering Layers for lights     | Disable Rendering Layers for Lights       | `_LIGHT_LAYERS`                                                                                                                                                                 | Forward and Deferred     |
| Reflection Probe blending       | Disable Probe Blending                | `_REFLECTION_PROBE_BLENDING`                                                                                                                                                    | Forward and Deferred     |
| Reflection Probe box projection | Disable Box Projection              | `_REFLECTION_PROBE_BOX_PROJECTION`                                                                                                                                              | Forward and Deferred     |
| Render Pass                     | Disable **Native Render** in all Renderers that URP Assets use.                                                                                                                            | `_RENDER_PASS_ENABLED`                                                                                                                                                          | Forward and Deferred     |
| Shadows from additional lights  | In the URP Asset, in the **Additional Lights** section, disable ​**Cast Shadows**​.                                                                                                | `_ADDITIONAL_LIGHT_SHADOWS`                                                                                                                                                     | Forward and Deferred     |
| Shadows from the main light     | In the URP Asset, in the **Main Light** section, disable ​**Cast Shadows**​. The keywords Unity removes might depend on your settings.                                             | `_MAIN_LIGHT_SHADOWS`, `_MAIN_LIGHT_SHADOWS_CASCADE`, `_MAIN_LIGHT_SHADOWS_SCREEN`                                                                                      | Forward and Deferred     |
| Soft shadows                    | In the URP Asset, in the **Shadows** section, disable ​**Soft shadows**​.                                                                                                          | `_SHADOWS_SOFT`                                                                                                                                                                 | Forward and Deferred     |

| **Volume Override removed** | **Shader keywords this turns off**                                   |
| ----------------------------------- | ---------------------------------------------------------------------------- |
| Bloom                             | `_BLOOM_HQ`, `BLOOM_HQ_DIRT`, `_BLOOM_LQ`, `BLOOM_LQ_DIRT` |
| Chromatic Aberration              | `_CHROMATIC_ABERRATION`                                                |
| Film Grain                        | `_FILM_GRAIN`                                                          |
| HDR Grading                       | `_HDR_GRADING`                                                         |
| Lens Distortion                   | `_DISTORTION`                                                          |
| Tonemapping                       | `_TONEMAP_ACES`, `_TONEMAP_NEUTRAL`, `_TONEMAP_GRADING`        |
。</description><guid isPermaLink="true">https://ogazen.github.io/post/guan-jian-zi-%20-bian-ti.html</guid><pubDate>Fri, 07 Nov 2025 08:33:43 +0000</pubDate></item><item><title>URP Shader常用函数</title><link>https://ogazen.github.io/post/URP%20Shader-chang-yong-han-shu.html</link><description>[URP 文档](https://docs.unity.cn/cn/Packages-cn/com.unity.render-pipelines.universal@14.1/manual/)

### 在自定义 URP 着色器中转换坐标

&gt; 1.在着色器文件的 `HLSLPROGRAM` 内部添加 `#include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'`。</description><guid isPermaLink="true">https://ogazen.github.io/post/URP%20Shader-chang-yong-han-shu.html</guid><pubDate>Fri, 07 Nov 2025 06:27:38 +0000</pubDate></item><item><title>UILoading 过渡Shader</title><link>https://ogazen.github.io/post/UILoading%20-guo-du-Shader.html</link><description>&lt;details&gt;
	&lt;summary&gt;URP/Loading_Fixed&lt;/summary&gt;

```hlsl
Shader 'URP/Loading_Fixed'
{
    Properties
    {
        [PerRendererData]_MainTex ('Texture', 2D) = 'white' {}
        _Color ('Color', Color) = (1,1,1,1)

        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip ('Use Alpha Clip', Float) = 0
        [Toggle] _Invert('Invert', Float) = 0
        _Radius('Radius', Range(-0.5,1.5)) = 0.1
        _Smooth('Smooth', Range(0,10)) = 0.2
        _OffsetX('Offset Center U',Range(0,1)) = 0.5
        _OffsetY('Offset Center V',Range(0,1)) = 0.5
        _StampTex('Stamp', 2D) = 'black' {}
        _StampColor('StampColor', Color) = (1,1,1,1)

        _GradientColorTop('Gradient Color Top', Color) = (1,1,1,1)
        _GradientColorDown('Gradient Color Down', Color) = (1,1,1,1)
    }

    SubShader
    {
        Tags
        {
            'RenderType'='Transparent'
            'RenderPipeline'='UniversalPipeline'
            'IgnoreProjector'='True'
            'Queue'='Transparent'
            'CanUseSpriteAtlas'='True'
        }

        Cull Off
        Lighting Off
        ZWrite Off
        ZTest Off
        Blend SrcAlpha OneMinusSrcAlpha

        Pass
        {
            HLSLPROGRAM
            #pragma target 3.0
            #pragma vertex Vert
            #pragma fragment Frag
            #pragma multi_compile _ UNITY_UI_ALPHACLIP

            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'

            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);

            TEXTURE2D(_StampTex);
            SAMPLER(sampler_StampTex);

            CBUFFER_START(UnityPerMaterial)
                half4 _Color;
                half4 _MainTex_ST;
                half4 _MainTex_TexelSize;

                half4 _StampTex_ST;
                half4 _StampColor;

                half4 _GradientColorTop;
                half4 _GradientColorDown;

                half _OffsetX;
                half _OffsetY;
                half _Radius;
                half _Smooth;
                half _Invert;
            CBUFFER_END

            struct Attributes
            {
                float4 positionOS : POSITION;   // 改为 float
                half4  color      : COLOR;
                half2  uv         : TEXCOORD0;
            };

            struct Varyings
            {
                float4 positionCS : SV_POSITION; // 改为 float
                half4  color      : COLOR;
                half2  uv         : TEXCOORD0;
                half2  stampuv    : TEXCOORD1;
            };

            Varyings Vert (Attributes IN)
            {
                Varyings OUT;
                OUT.positionCS = TransformObjectToHClip(IN.positionOS);
                OUT.uv = IN.uv;

                // 等价于 TRANSFORM_TEX(IN.uv, _StampTex)
                OUT.stampuv = IN.uv * _StampTex_ST.xy + _StampTex_ST.zw;

                OUT.color = IN.color;
                return OUT;
            }

            half4 Frag (Varyings IN) : SV_Target
            {
                half2 uv = IN.uv;

                // 动态屏幕分辨率
                half2 screen = GetScaledScreenParams();
                half aspectRatio = screen.y / screen.x;

                
                // 你的原始 alpha/圆环/反转等逻辑（按需打开）
                half aspect = max(aspectRatio, 1e-4);
                uv.y *= aspect; // 以水平宽度为基准 对应屏蔽 比例 X:（0，1） Y:（0，1*aspect）

                half smoothV = _Smooth * 0.2h; // 0.2h 调节变化率
                half alpha = distance(uv, half2(_OffsetX, _OffsetY * aspect)) - _Radius;
                alpha = smoothstep(0.0h, smoothV, alpha);

                half invOn = step(_Invert, 0.1h); // 反转
                alpha = invOn * (1.0h - alpha) + (1.0h - invOn) * alpha;

                half4 col = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv) * IN.color * _Color;
                col.a *= saturate(1.0h - alpha);

                // 渐变与 Stamp（按需）
                half3 grad = lerp(_GradientColorTop.rgb, _GradientColorDown.rgb, 1.0h - IN.uv.y);
                col.rgb *= grad;

                half stampA = SAMPLE_TEXTURE2D(_StampTex, sampler_StampTex, IN.stampuv).a;
                col.rgb = lerp(col.rgb, _StampColor.rgb * col.rgb, stampA);

                #ifdef UNITY_UI_ALPHACLIP
                    clip(col.a - 0.001h);
                #endif

                return col;
            }
            ENDHLSL
        }
    }
    
}
```

&lt;/details&gt;

###### 简介

&gt; 中心圆形过渡动画shader


。</description><guid isPermaLink="true">https://ogazen.github.io/post/UILoading%20-guo-du-Shader.html</guid><pubDate>Thu, 06 Nov 2025 06:46:42 +0000</pubDate></item><item><title>Development Softwares</title><link>https://ogazen.github.io/post/Development%20Softwares.html</link><description>#### 工具

1. Unity国际 [NoUnityCN | Unity国际版下载站 - 让游戏开发更加简单](https://www.nounitycn.top/)
2. Wampserver64 [Download Wampserver 64bits - WampServer](https://www.wampserver.com/)
3. TeamViewer [TeamViewer——数字化工作场所平台](https://www.teamviewer.cn/cn/)
4. Jadx [skylot/jadx: Dex to Java decompiler](https://github.com/skylot/jadx)
5. Docker [Docker: Accelerated Container Application Development](https://www.docker.com/)
6. AndroidStudio [Android Studio download archives  |  Android Developers](https://developer.android.google.cn/studio/archive?hl=en)
7. Rider [Rider: The Cross-Platform .NET IDE from JetBrains](https://www.jetbrains.com/rider/)
8. VScode [Download Visual Studio Code - Mac, Linux, Windows](https://code.visualstudio.com/download)
9. Visual Studio [Visual Studio: 适用于软件开发的 IDE 和代码编辑器](https://visualstudio.microsoft.com/zh-hans/)
10. NotePad++ [Notepad++ Official Website - Free Open Source Text Editor Download](http://www.notepadplus.com.cn/en/)
11. WSL2 [Manual installation steps for older versions of WSL | Microsoft Learn](https://learn.microsoft.com/en-us/windows/wsl/install-manual)
12. MuMu模拟器 [Mumu模拟器4.1.25+5.1.3去广告整合包](https://www.52pojie.cn/thread-2030503-1-1.html)

#### 环境

1. Nodejs [Node.js — Run JavaScript Everywhere](https://nodejs.org/zh-cn)
   
   * [Node.js 下载安装与环境配置全流程（保姆级详解）| 图文详解，快速上手\_node安装教程图文详解-CSDN博客](https://blog.csdn.net/Natsuago/article/details/145567734)
2. python [Python.org - Python 编程语言](https://pythonlang.cn/)
   
   * [Python安装与环境配置全程详细教学（包含Windows版和Mac版）\_python环境-CSDN博客](https://blog.csdn.net/sensen_kiss/article/details/141940274)
3. java [Java | Oracle](https://www.java.com/en/)
   
   * [【2025年最新版】Java JDK安装、环境配置教程 （图文非常详细）\_jdk安装及配置教程-CSDN博客](https://blog.csdn.net/2401_83413238/article/details/145382639)
4. dotnet-sdk [Download .NET (Linux, macOS, and Windows) | .NET](https://dotnet.microsoft.com/en-us/download)


#### 效率

1. Everying [voidtools](https://www.voidtools.com/zh-cn/)
2. QuickLook [QL-Win/QuickLook: Bring macOS “Quick Look” feature to Windows](https://github.com/QL-Win/QuickLook)
3. Snipate [Snipaste](https://www.snipaste.com/)
4. Typora [Typora CSDN博客](https://blog.csdn.net/2301_76781991/article/details/151789744)
5. GeoGebra [GeoGebra 计算器和应用](https://www.geogebra.org/download)
6. ILspy[icsharpcode/ILSpy: .NET Decompiler with support for PDB generation, ReadyToRun, Metadata (&amp;more) - cross-platform!](https://github.com/icsharpcode/ILSpy)
7. PotPlayer [Download PotPlayer - Free multimedia player](https://potplayer.info/download/)
8. SQLite Personal [SQLite administration | SQLite Expert](https://www.sqliteexpert.com/download.html)
9. PIX [Download - PIX on Windows](https://devblogs.microsoft.com/pix/download/)
10. DirectXRepair
11. Internet Download Manager
12. BandiZip
13. BandiCam
14. XMind
15. IDA-反编译

#### AI

1. DeepSeek [DeepSeek - 探索未至之境](https://chat.deepseek.com/)
2. Qwen [Qwen](https://qwen.ai)
3. HuggingFace [Hugging Face – The AI community building the future.](https://huggingface.co/)

#### 科学上网

* [Steamcommunity 302 Ver.13.0.07\_fix – Dogfight360](https://www.dogfight360.com/blog/18682/)
* [Bingo Acceleration](https://hi.bingo/)

#### 娱乐

* [小叽资源 - Free Share](https://steamzg.com/)

#### 其他

1. SVN [首页 · TortoiseSVN - TortoiseSVN 软件](https://tortoisesvn.subversion.org.cn/)
2. Github Desktop [Download GitHub Desktop | GitHub Desktop](https://desktop.github.com/download/)
   * [cli/cli: GitHub’s official command line tool](https://github.com/cli/cli)
3. Git [Git](https://git-scm.com/)
。</description><guid isPermaLink="true">https://ogazen.github.io/post/Development%20Softwares.html</guid><pubDate>Wed, 22 Oct 2025 09:35:12 +0000</pubDate></item><item><title>Local Github Actions</title><link>https://ogazen.github.io/post/Local%20Github%20Actions.html</link><description>用于本地化测试处理Github流水线（Windows）

&gt; 工具：vscode act docker.desktop

1. 安装vscode 扩展 [`Github Local Actions`](https://marketplace.visualstudio.com/items?itemName=SanjulaGanepola.github-local-actions)
   
   * [扩展地址源码](https://github.com/SanjulaGanepola/github-local-actions)
   * [扩展文档](https://sanjulaganepola.github.io/github-local-actions-docs/)
2. 安装最新 [act CLI](https://github.com/nektos/act/releases)
   
   * [nektos/act: 自构建源码](https://github.com/nektos/act)
   * 配置环境变量
3. 安装Docker.desktop [WSL 的手动安装步骤](https://learn.microsoft.com/zh-cn/windows/wsl/install-manual)
   
   * 启动CPU虚拟化，添加`虚拟机平台`
   * 添加 `使用于Linux的Windows子系统`
   * 安装`WSL2`
4. 启动Docker安装`catthehacker/ubuntu:act-24.04`镜像
5. 重启vscode可看到 `Github Local Action` 测边栏扩展已激活
6. Github根目录添加`.actrc`文件，写入

```
-P ubuntu-24.04=catthehacker/ubuntu:act-24.04
--pull=false
```

7. 运行测试
8. 其他参考链接
   * [码农必备！本地调试神器act，GitHub Actions最佳拍档 - 技术栈](https://jishuzhan.net/article/1963967697509203969)
。</description><guid isPermaLink="true">https://ogazen.github.io/post/Local%20Github%20Actions.html</guid><pubDate>Wed, 22 Oct 2025 06:29:21 +0000</pubDate></item><item><title>模拟平面水（Beta）</title><link>https://ogazen.github.io/post/mo-ni-ping-mian-shui-%EF%BC%88Beta%EF%BC%89.html</link><description>### 平面水shader

&lt;details open&gt;
    &lt;summary&gt;WaterPanel&lt;/summary&gt;

```hlsl
Shader 'URP/WaterPanel'
{
    Properties
    {
        [MainTexture]_MainTex ('Texture', 2D) = 'white' {}
        [MainColor]_Color ('Color',Color) = (1,1,1,1)

        // 第一步
        [Header(Depth And Color)]
        [Space()]
        _DepthIntensity ('Depth Intensity',Range(0,1)) = 0.05
        _EdgeColor ('Edge Color',Color) = (1,1,1,1)
        _WaterColor ('Water Color',Color) = (1,1,1,1)

        // 第二步 法线贴图
        [Header(Normal Texture)]
        [Space()]
        _NormalTex('Normal Texture',2D) = 'white' {}
        _FlowSpeed('Flow Speed',Float) = 1
        _NormalMixture('Normal Mixture',Float) = 1


        // 第三步 高光
        [Header(Specular Color)]
        [Space()]
        _SpecularColor('Specular Color',Color)=(1,1,1,1)
        _SpecularIntensity('Specular Intensity',float)=1
        _Shininess('Shininess',float)=1


        // 第四步 反射 CubeMap
        [Header(Reflect Texture)]
        [Space()]
        _ReflectTex2('ReflectTex2',2D) = 'white' {}
        _ReflectMixture('Reflect Mixture',float)=1
        _FresnelIntensity('Fresnel Intensity',float)=1



        // 第五步 水下折射扭曲
        [Header(Distort Texture)]
        [Space()]
        _DistortTex('DistortTex',2D) = 'white'{}
        _Refract_X('Refract_X',float)=1
        _Refract_Y('Refract_Y',float)=1
        _DistortIntensity('Distort Intensity',float)=0 //折射纹理的扭曲强度


        // 第六步 水下焦散
        [Header(Caustic Texture)]
        [Space()]
        _CausticTex('CausticTex',2D)='white'{}
        _OffsetY('Caustic OffsetY',float)=1
        _CausticIntensity('Caustic Intensity',float)=1


        // 第七步 水面泡沫
        [Header(Foam Texture)]
        [Space()]
        _FoamTex('FoamTex',2D)='white'{}
        _FoamColor('Foam Color',Color)=(1,1,1,1)
        _FoamNoise('FoamNoise',float)=1
        _FoamMultiplier('Foam Multiplier',Float) = 1
    }
    SubShader
    {
        Tags
        {
            'RenderType'='Transparent'
            'RenderPipeline'='UniversalRenderPipeline'
            'IgnoreProjector'='true'
            'Queue'='Transparent' // Transparent AlphaTest Geometry Background
        }
        LOD 100

        Pass
        {
            HLSLPROGRAM


            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl'
            #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl'
            // #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl'
            // #include 'Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareOpaqueTexture.hlsl'

            #pragma vertex Vert
            #pragma fragment Frag



            TEXTURE2D_X(_MainTex);
            TEXTURE2D_X(_NormalTex);
            TEXTURE2D_X(_ReflectTex2);
            TEXTURE2D_X(_DistortTex);
            TEXTURE2D_X(_CausticTex);
            TEXTURE2D_X(_FoamTex);

            TEXTURE2D_X(_CameraDepthTexture);
            TEXTURE2D_X(_CameraOpaqueTexture);
            SAMPLER(sampler_MainTex);

            CBUFFER_START(UnityPerMaterial)
            half4 _Color;
            half4 _MainTex_ST;

            // 第一步
            half _DepthIntensity;
            half4 _EdgeColor;
            half4 _WaterColor;

            // 第二步
            half4 _NormalTex_ST;
            half _FlowSpeed;
            half _NormalMixture;

            // 第三步
            half4 _SpecularColor;
            half _SpecularIntensity;
            half _Shininess;

            // 第四步
            half _ReflectMixture;
            half _FresnelIntensity;
            half4 _ReflectTex2_ST;


            // 第五步
            half4 _DistortTex_ST;
            half _Refract_X;
            half _Refract_Y;
            half _DistortIntensity;


            // 第六步
            half4 _CausticTex_ST;
            half _OffsetY;
            half _CausticIntensity;


            // 第七步
            half4 _FoamTex_ST;
            half4 _FoamColor;
            half _FoamNoise;
            half _FoamMultiplier;
            CBUFFER_END


            struct Attributes
            {
                half4 position : POSITION;
                half2 uv : TEXCOORD0;

                // 第二步
                half4 normalUV : TEXCOORD1;
                half3 normal : NORMAL;
            };


            struct Varyings
            {
                half4 positionHCS : SV_POSITION;
                half2 uv : TEXCOORD0;

                // 第一步
                half3 positionView : TEXCOORD1;
                half3 positionWorld : TEXCOORD2;


                // 第二步
                half4 normalUV : TEXCOORD3;
                half3 normalWorld : TEXCOORD4;

                // 补丁
                half4 screenPos : TEXCOORD5;
            };


            Varyings Vert(Attributes IN)
            {
                Varyings OUT;
                // 第一步
                OUT.positionHCS = TransformObjectToHClip(IN.position);
                OUT.positionWorld = TransformObjectToWorld(IN.position);
                OUT.positionView = TransformWorldToView(OUT.positionWorld);

                // 第二步
                OUT.normalWorld = TransformObjectToWorldNormal(IN.normal);
                const half2 _mul1 = half2(1,1);
                const half2 _mul2 = half2(-1.15,0.8);
                OUT.normalUV.xy = TRANSFORM_TEX(IN.normalUV,_NormalTex) + _Time.y * _FlowSpeed * _mul1;
                OUT.normalUV.zw = TRANSFORM_TEX(IN.normalUV,_NormalTex) + _Time.y * _FlowSpeed * _mul2;
                OUT.uv = TRANSFORM_TEX(IN.uv,_FoamTex) + _Time.y * _FlowSpeed;

                // 补丁
                OUT.screenPos = ComputeScreenPos(OUT.positionHCS);

                return OUT;
            }



            half4 Frag(Varyings IN) : SV_Target
            {
                /* 第一步 */
                //根据深度差设置水面颜色
                half2 ScreenUV = IN.positionHCS.xy / _ScreenParams.xy; //屏幕UV
                half4 depthTex = SAMPLE_TEXTURE2D(_CameraDepthTexture,sampler_MainTex,ScreenUV); //采样深度图
                half depth_eye = LinearEyeDepth(depthTex,_ZBufferParams); //将深度纹理的深度值转换到视图空间
                //（此时水体面片不渲染到深度图中）用深度图中的深度值与水体面片的在视图空间的深度值做差值，两者交接处颜色为0
                half depth_eye_viewZ = depth_eye + IN.positionView.z; //i.positionVS.z为负值，做差值时需两者相加
                //_depthIntensity用于调节深度差变化
                half depthDifference = saturate( depth_eye_viewZ * _DepthIntensity ); 
                //水面颜色
                half4 col = lerp(_EdgeColor,_WaterColor,depthDifference);
                // return col;



                /* 第二步 */
                //水面法线
                //利用两个流动不同方向的normalUV来采样法线纹理，最后将两者混合，做出水面流动的效果
                half4 NormalTex01 = SAMPLE_TEXTURE2D(_NormalTex,sampler_MainTex,IN.normalUV.xy);
                half4 NormalTex02 = SAMPLE_TEXTURE2D(_NormalTex,sampler_MainTex,IN.normalUV.zw);
                half4 normalCalc = NormalTex01 * NormalTex02;
                // return col + normalCalc;


                /* 第三步 */
                //水面高光
                //利用_NormalMixture来混合模型本身法线和法线纹理
                half3 N = normalize(lerp(IN.normalWorld,normalCalc,_NormalMixture));
                Light light = GetMainLight();
                half3 L = light.direction; // 看向灯光方向
                half3 V = normalize(_WorldSpaceCameraPos - IN.positionWorld); // 看向摄像机
                half3 H = normalize(L+V); // L 和 V 的中间向量
                half4 Specular = _SpecularColor * _SpecularIntensity * pow(max(0,dot(N,H)),_Shininess);
                // return Specular + col;



                /* 第四步 */
                //水面反射以及菲尼尔
                //利用_ReflectMixture来控制法线取值，与上一步制作高光的法线值区分
                half3 N1 = normalize( lerp(IN.normalWorld,normalCalc,_ReflectMixture) );
                // 通过Schlick近似菲涅尔函数权重取折射和反射采样 空气折射率1 水折射率1.333
                half Fresnel2 = pow(1 - saturate(dot(V, N1)), _FresnelIntensity);
                // return ReflectTex2;



                /* 第五步 */
                //水下的折射扭曲
                //利用水体面片的世界空间下坐标采样用于扭曲水下的纹理
                half3 DistortTex = UnpackNormal(SAMPLE_TEXTURE2D(_DistortTex,sampler_MainTex,IN.positionWorld.xz * half2(_Refract_X,_Refract_Y)+_Time.y));
                //偏移值 _DistortIntensity为扭曲强度值
                half2 offset = DistortTex.xy * _DistortIntensity;
                //扭曲UV值
                half2 DistortUV = ScreenUV + offset; 
                //利用扭曲后的屏幕UV采样深度图
                half DistortDepth = SAMPLE_TEXTURE2D(_CameraDepthTexture,sampler_MainTex,DistortUV);
                //将深度图中的深度信息转换到视图空间
                DistortDepth = LinearEyeDepth(DistortDepth,_ZBufferParams);
                //计算深度图和水体面片在视图空间中的深度差（i.positionVS.z为负值，所以两者要相加）
                half DistDepthDifferent = saturate(DistortDepth + IN.positionView.z);
                //消除水面以上物体的扭曲，因为水面以上物体的深度值小于i.positionVS.z,所以DistDepthDifferent值为负时，使水面以上物体采样屏幕纹理的UV为屏幕UV(不进行扭曲)
                if(!all(DistDepthDifferent)) DistortUV = ScreenUV;
                //最后利用上面计算得到的UV来采样屏幕纹理
                half4 RefractTex = SAMPLE_TEXTURE2D(_CameraOpaqueTexture,sampler_MainTex,DistortUV);
                half4 ReflectTex2 = SAMPLE_TEXTURE2D(_ReflectTex2,sampler_MainTex,DistortUV);
                half4 refract_reflect = ReflectTex2 * Fresnel2 + RefractTex * (1-Fresnel2);






                /* 第六步 */
                //水下的焦散
                //因为焦散纹理需要处于水底，而我们只能使用水体面片来采样焦散纹理。</description><guid isPermaLink="true">https://ogazen.github.io/post/mo-ni-ping-mian-shui-%EF%BC%88Beta%EF%BC%89.html</guid><pubDate>Thu, 25 Sep 2025 07:53:35 +0000</pubDate></item><item><title>ShaderLab 数学函数</title><link>https://ogazen.github.io/post/ShaderLab%20-shu-xue-han-shu.html</link><description>### 修饰符

| **修饰符** | **解析**                                                     |
| :--------: | :----------------------------------------------------------- |
|   const    | 变量被定义成常量的话，在程序中，就不能再对该变量赋值，除非const和uniform，varying一起使用。</description><guid isPermaLink="true">https://ogazen.github.io/post/ShaderLab%20-shu-xue-han-shu.html</guid><pubDate>Mon, 22 Sep 2025 09:04:18 +0000</pubDate></item><item><title>My Blog</title><link>https://ogazen.github.io/post/My%20Blog.html</link><description>Thank For Gmeek Template。</description><guid isPermaLink="true">https://ogazen.github.io/post/My%20Blog.html</guid><pubDate>Fri, 19 Sep 2025 07:07:29 +0000</pubDate></item></channel></rss>